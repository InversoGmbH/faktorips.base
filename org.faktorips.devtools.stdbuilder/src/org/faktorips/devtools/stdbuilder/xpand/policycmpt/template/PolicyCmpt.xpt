«IMPORT org::faktorips::devtools::stdbuilder»
«IMPORT org::faktorips::devtools::core::builder::naming»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::template»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::productcmpt::model»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::CommonGeneratorExtensions»

«DEFINE main FOR XPolicyCmptClass»
	«FILE getFileName(BuilderAspect::IMPLEMENTATION)-»
package «getPackageName(BuilderAspect::IMPLEMENTATION)»;

	«EXPAND CommonDefinitions::ImportBlock FOREACH context.imports ONFILECLOSE»
	
	/**
	 «IF generatePublishedInterfaces-»
	 *	«localizedJDoc("CLASS", getSimpleName(BuilderAspect::INTERFACE))»
	 «ELSE-»
	 * «localizedJDocOrDescription("CLASS_NO_INTERFACE", name, description)»
	 «ENDIF-»
	 * «getAnnotations(AnnotatedJavaElementType::ELEMENT_JAVA_DOC)»
	 * @generated
	 */
	 «getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS)-»
	public «abstract()» class «implClassName» extends «superclassName-» «EXPAND CommonDefinitions::implementedInterfaces»{

		«IF !hasConfiguredSupertype()»
			/**
			 * @generated
	 		 */
			@«XmlJavaTypeAdapter()»(value = «ModelObjectConfigurationXmlAdapter()».class)
    		@«XmlAttribute()»(name = "product-component.id")
    		private final «ModelObjectConfiguration()» modelObjectConfiguration;
    	«ENDIF»	

		«IF !generatePublishedInterfaces-»
			«EXPAND PolicyCmptAssociation::constants FOREACH associations»
			«EXPAND ValidationRule::constants FOREACH validationRules»
		«ENDIF-»

		«FOREACH attributes AS this-»
			«IF !published || !generatePublishedInterfaces-»
				«EXPAND PolicyCmptAttribute::constantForPropertyName-»
				«EXPAND PolicyCmptAttribute::constantForValueSet-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«FOREACH attributes AS this-»
			«IF !published || !generatePublishedInterfaces-»
				«EXPAND PolicyCmptAttribute::constantField-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«EXPAND PropertyChangeSupport::fieldDefinition-»

		«FOREACH attributes AS this-»
			«IF !constant-»
				«EXPAND PolicyCmptAttribute::memberField-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«EXPAND PolicyCmptAssociation::field FOREACH associations-»
		
		«EXPAND constructors-»
		
		«EXPAND getterForProductAttributes(this) FOREACH productAttributes-»
		
		«FOREACH attributes AS this-»
			«EXPAND PolicyCmptAttribute::allowedValuesMethod-»
			«EXPAND PolicyCmptAttribute::getter-»
			«EXPAND PolicyCmptAttribute::setter-»
			«EXPAND PolicyCmptAttribute::setterInternal-»
		«ENDFOREACH-»

		«EXPAND PolicyCmptAssociation::methods FOREACH associations-»
		
		«EXPAND DerivedUnionAssociation::methodsForDerivedUnion(this) FOREACH subsettedDerivedUnions-»

		«EXPAND Methods::method FOREACH methods-»
		
		«EXPAND getterForTables(this) FOREACH productTables-»
		
		/**
	     * «localizedJDoc("METHOD_INITIALIZE")»
	     * 
	     * @restrainedmodifiable
	     */
	     «overrideAnnotationIf(hasSupertype() || configured)»
	    public void «initialize()» {
	    	«IF hasSupertype()-»
		        super.«initialize()»;
		    «ENDIF-»
		    «IF configured && (!attributesToInitWithProductData.isEmpty || !attributesToInitWithoutProductDataAndOverwritten.isEmpty)-»
				if («methodNameGetProductCmptGeneration»() == null) {
					return;
				}
		    «ENDIF-»
	        «EXPAND initializeAttributesWithProductData-»
	    	«IF hasSupertype()-»
		        «EXPAND initializeAttributesWithoutProductDataAndOverwritten-»
	        «ENDIF-»
		    // begin-user-code
		    // end-user-code
	    }
		
		«IF configured-»
			«EXPAND getAndSetProductComponent FOR productCmptNode-»
			«EXPAND getAndSetProductComponentGeneration FOR productCmptGenerationNode-»
			«EXPAND generalMethodsForConfiguredPolicyCmpts-»
		«ENDIF-»
		
		«EXPAND generateCodeForDependentObject»
		
		«EXPAND DerivedUnionAssociation::getterForDetailToMaster(this) FOREACH detailToMasterDerivedUnionAssociations-»
	   
		«EXPAND PropertyChangeSupport::generalMethods-»
		
		«EXPAND generalMethods-»

		«EXPAND ValidationRule::validationRuleMethods FOREACH validationRules-»
		
		}
	«ENDFILE»
«ENDDEFINE»

«DEFINE initializeAttributesWithProductData FOR XPolicyCmptClass-»
	«FOREACH attributesToInitWithProductData AS this-»
		«EXPAND PolicyCmptAttribute::initConfigurableAttribute-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE initializeAttributesWithoutProductDataAndOverwritten FOR XPolicyCmptClass-»
   	«FOREACH attributesToInitWithoutProductDataAndOverwritten AS this-»
   		«methodNameSetterInternalIfGenerateChangeSupport»(«defaultValueCode»);
   	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE constructors FOR XPolicyCmptClass-»
	/**
     * «localizedJDoc("CONSTRUCTOR", implClassName)»
     * «getAnnotations(AnnotatedJavaElementType::ELEMENT_JAVA_DOC)»
     * @generated
     */
    public «method(implClassName)» {
        super();
        «IF !hasConfiguredSupertype()-»
        	modelObjectConfiguration = new «ModelObjectConfiguration()»();
        «ENDIF»	
        «EXPAND initializationForOverrideAttributes-»
    }
    «IF configured»
		/**
	     * «localizedJDoc("CONSTRUCTOR", implClassName)»
	     * «getAnnotations(AnnotatedJavaElementType::ELEMENT_JAVA_DOC)»
	     * @generated
	     */
	    public «method(implClassName, productCmptClassName, "productCmpt")» {
	    	«IF hasConfiguredSupertype()-»
        		super(productCmpt);
        	«ELSE-»
	    		super();
        		modelObjectConfiguration = new «ModelObjectConfiguration()»(productCmpt);
        	«ENDIF»	
	        «EXPAND initializationForOverrideAttributes-»
	    }
    «ENDIF»
«ENDDEFINE»

«DEFINE getterForProductAttributes(XPolicyCmptClass currentClass) FOR XProductAttribute-»
	«IF !overwrite-»
		 /**
	     * «localizedJDoc("METHOD_GET_VALUE_IN_POLICY", name)»
	     «IF descriptionForJDoc.length > 0-»
	     * «descriptionForJDoc»
		 «ENDIF-»
	     * «getAnnotations(AnnotatedJavaElementType::ELEMENT_JAVA_DOC)»
	     * @generated
	     */
	    «IF generatePublishedInterfaces»public«ELSE»protected«ENDIF» «javaClassName» «method(methodNameGetter)» {
	    	«IF changingOverTime-»
	        	return «currentClass.methodNameGetProductCmptGeneration»().«methodNameGetter»();
	        «ELSE-»
	        	return «currentClass.methodNameGetProductCmpt»().«methodNameGetter»();
	        «ENDIF-»
	    }
	«ENDIF-»
«ENDDEFINE»

«DEFINE getterForTables(XPolicyCmptClass policyClass) FOR XTableUsage-»
    /**
     * «localizedJDoc("METHOD_GET_TABLE_IN_POLICY", name)»
     * «getAnnotations(AnnotatedJavaElementType::ELEMENT_JAVA_DOC)»
     * @generated
     */
    public «tableClassName» «method(methodNameGetter)» {
    	«policyClass.productCmptGenerationNode.implClassName» productCmpt = «castToImplementation(policyClass.productCmptGenerationNode.implClassName)»«policyClass.methodNameGetProductCmptGeneration»();
        if (productCmpt == null) {
            return null;
        }
        return productCmpt.«methodNameGetter»();
    }
«ENDDEFINE»

«DEFINE initializationForOverrideAttributes FOR XPolicyCmptClass-»
	«FOREACH attributes AS this-»
		«IF generateDefaultInitialize-»
			«methodNameSetterInternalIfGenerateChangeSupport»(«defaultValueCode»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE getAndSetProductComponent FOR XProductCmptClass-» 
		/**
		 * «inheritDocOrJavaDocIf(genInterface(), "METHOD_GET_PRODUCTCMPT", name, policyCmptClass.name)»
		 * 
		 * @generated
		 */
		 «overrideAnnotationForPublishedMethodAndIf(!genInterface())-»
		 public «interfaceName» «method(methodNameGetProductCmpt)»
		 «IF genInterface()»;«ELSE-»
		 {
		 	return («interfaceName») «getProductComponent()»;
		 }
		 «ENDIF»

		/**
		 * «inheritDocOrJavaDocIf(genInterface(), "METHOD_SET_PRODUCTCMPT",  name, nameForVariable, "initPropertiesWithConfiguratedDefaults")»
		 * 
		 * @generated
		 */
		 «overrideAnnotationForPublishedMethodAndIf(!genInterface())-»
		 public void «method(methodNameSetProductCmpt, interfaceName, nameForVariable, "boolean", "initPropertiesWithConfiguratedDefaults")»
		 «IF genInterface()»;«ELSE-»
		 {
	        «setProductComponent(nameForVariable)»;
	        if (initPropertiesWithConfiguratedDefaults) {
	            «initialize()»;
	        }
		 }
			 «IF !policyCmptClass.hasConfiguredSupertype()»
				/**
				 * {@inheritDoc}
				 * 
				 * @generated
				 */
				 @Override
				 public «IProductComponent()» «getProductComponent()» {
				 	return modelObjectConfiguration.«getProductComponent()»;
				 }
				 
				/**
				 * @generated
				 */
				 «overrideAnnotationIf(policyCmptClass.hasConfiguredSupertype())»
				 public void setProductComponent(IProductComponent productComponent) {
				 	modelObjectConfiguration.setProductComponent(productComponent);
				 }
			 «ENDIF»
		 «ENDIF»
«ENDDEFINE»
		 
«DEFINE getAndSetProductComponentGeneration FOR XProductCmptGenerationClass-» 
		/**
		 * «inheritDocOrJavaDocIf(genInterface(), "METHOD_GET_PRODUCTCMPT_GENERATION", generationConceptNameSingular, name, policyCmptClass.name)»
		 * 
		 * @generated
		 */
		 «overrideAnnotationForPublishedMethodAndIf(!genInterface())-»
		 public «interfaceName» «method(methodNameGetProductComponentGeneration)»
		 «IF genInterface()»;«ELSE-»
		 {
		 	return («interfaceName») getProductCmptGeneration();
		 }
		 «ENDIF»
	
		/**
		 * «inheritDocOrJavaDocIf(genInterface(), "METHOD_SET_PRODUCTCMPT_GENERATION",  name, nameForVariable)»
		 * 
		 * @generated
		 */
		 «overrideAnnotationForPublishedMethodAndIf(!genInterface())-»
		 public void «method(methodNameSetProductComponentGeneration, interfaceName, nameForVariable)»
		 «IF genInterface()»;«ELSE-»
		 {
	        «setProductCmptGeneration(nameForVariable)»;
		 }
			 «IF !policyCmptClass.hasConfiguredSupertype()»
				 /**
				  * {@inheritDoc}
				  * 
				  * @generated
				  */
				 @Override
				 public «IProductComponentGeneration()» «getProductCmptGeneration()» {
				 	return modelObjectConfiguration.getProductCmptGeneration(getEffectiveFromAsCalendar());
				 }
				 
				/**
				 * @generated
				 */
				 «overrideAnnotationIf(policyCmptClass.hasConfiguredSupertype())»
				 public void «setProductCmptGeneration("IProductComponentGeneration productComponentGeneration")» {
				 	modelObjectConfiguration.«setProductCmptGeneration("productComponentGeneration")»;
				 }
			 «ENDIF»
		 «ENDIF»
«ENDDEFINE»

«DEFINE generalMethodsForConfiguredPolicyCmpts FOR XPolicyCmptClass-»
	   
	    /**
		 «IF hasConfiguredSupertype()-»
		 * {@inheritDoc}
		 «ELSE-»
     	 * This method is called when the effective from date has changed, so that the reference to the
		 * product component generation can be cleared. If this policy component contains child
		 * components, this method will also clear the reference to their product component generations.
		 * <p>
		 * The product component generation is cleared if and only if there is a new effective from
		 * date. If {@link #getEffectiveFromAsCalendar()} returns <code>null</code> the product
		 * component generation is not reset, for example if this model object was removed from its
		 * parent.
		 * <p>
         * Clients may change the behavior of resetting the product component by overwriting
         * {@link #resetProductCmptGenerationAfterEffectiveFromHasChanged()} instead of this method.
     	 «ENDIF»
     	 *
	     * @generated
	     */
	    «overrideAnnotationIf(hasConfiguredSupertype())»
	    public void «effectiveFromHasChanged()» {
	    	«IF hasConfiguredSupertype()-»
	    		super.«effectiveFromHasChanged()»;
	        «ELSE-»
		        if («getEffectiveFromAsCalendar()» != null) {
	        		resetProductCmptGenerationAfterEffectiveFromHasChanged();
        		}
    		«ENDIF»
	        «EXPAND PolicyCmptAssociation::delegateEffectiveFromHasChanged FOREACH associations-»
	    }
		
		«IF !hasConfiguredSupertype()-»
			protected void resetProductCmptGenerationAfterEffectiveFromHasChanged() {
	        	modelObjectConfiguration.resetProductCmptGeneration();
	    	}
    	«ENDIF»
    
		«IF firstDependantTypeInHierarchy-»
	    	
			/**
			 * «inheritDoc()»
			 *
			 * @generated
			 */
	    	@Override
			public «Calendar()» «getEffectiveFromAsCalendar()» {
				«IModelObject()» parent = «getParentModelObject()»;
				if (parent instanceof «IConfigurableModelObject()») {
					return ((«IConfigurableModelObject()»)parent).«getEffectiveFromAsCalendar()»;
				}
				return null;
			}
	    «ELSEIF aggregateRoot-»
			/**
			 * «inheritDoc()»
			 *
			 * @generated
			 */
	    	@Override
			public «Calendar()» «getEffectiveFromAsCalendar()» {
	   			«IF hasConfiguredSupertype()-»
	   				return super.«getEffectiveFromAsCalendar()»;
				«ELSE-»
					«localizedComment("METHOD_GET_EFFECTIVE_FROM_TODO_LINE1")»
					«localizedComment("METHOD_GET_EFFECTIVE_FROM_TODO_LINE2")»
					«localizedComment("METHOD_GET_EFFECTIVE_FROM_TODO_LINE3")»
					return null;
				«ENDIF-»
			}
		«ENDIF-»
«ENDDEFINE»

«DEFINE generateCodeForDependentObject FOR XPolicyCmptClass-»
	«IF generateGetParentModelObject-»
	    /**
	     * «inheritDoc()»
	     * 
	     * @generated
	     */
	    @Override
	    public «IModelObject()» «getParentModelObject()» {
	    	«FOREACH associations AS this-»
	    		«IF implementedDetailToMasterAssociation-»
			        if («fieldName» != null) {
			            return «fieldName»;
			        }
		        «ENDIF-»
	    	«ENDFOREACH-»
	        «IF supertypeGenerateGetParentModelObject-»
	        	return super.«getParentModelObject()»;
		 	«ELSE-»
	        	return null;
		 	«ENDIF-»
	    }
    «ENDIF-»
	
«ENDDEFINE»

«DEFINE generalMethods FOR XPolicyCmptClass-»
	«IF generateInitPropertiesFromXML-»
	    /**
	     * «inheritDoc()»
	     * 
	     * @generated
	     */
	    @Override
	    protected void «initPropertiesFromXml(Map("String", "String")+" propMap", IRuntimeRepository()+" productRepository")» {
	        super.«initPropertiesFromXml("propMap", "productRepository")»;
	        «EXPAND PolicyCmptAttribute::initFromXmlMethodCall FOREACH attributes-»
	    }
	    «EXPAND PolicyCmptAttribute::initFromXmlMethod FOREACH attributes-»
    «ENDIF-»
    
    /**
     * «inheritDoc()»
     * 
     * @generated
     */
	@Override
    protected «AbstractModelObject()» «createChildFromXml(Element()+" childEl")» {
        «AbstractModelObject()» newChild = super.«createChildFromXml("childEl")»;
        if (newChild != null) {
            return newChild;
        }
        «EXPAND PolicyCmptAssociation::createTargetFromXmlMethodCall FOREACH associations-»
        return null;
    }
    
    «EXPAND PolicyCmptAssociation::createTargetFromXmlMethod FOREACH associations-»
    
    «IF generateMethodCreateUnresolvedReference-»
	    /**
	     * «inheritDoc()»
	     * 
	     * @generated
	     */
	    @Override
	    protected «IUnresolvedReference()» «createUnresolvedReference("Object objectId, String targetRole, String targetId")»
	            throws Exception {
	        «EXPAND PolicyCmptAssociation::createUnresolvedReference FOREACH associations-»
	        return super.createUnresolvedReference(objectId, targetRole, targetId);
	    }
    «ENDIF-»

	«IF generateDeltaSupport-»
    	«EXPAND DeltaSupport::computeDeltaMethod-»
    «ENDIF-»

    «IF generateCopySupport-»
    	«EXPAND CopySupport::copyMethods-»
    «ENDIF-»
    
    «IF generateVisitorSupport-»
    	«EXPAND VisitorSupport::acceptMethod-»
    «ENDIF-»
    
    «EXPAND validateMethods-»
«ENDDEFINE»

«DEFINE validateMethods FOR XPolicyCmptClass-»
    /**
     * «localizedJDoc("VALIDATE_SELF", name)»
     * 
     * @generated
     */
	@Override
    public boolean «validateSelf(MessageList()+" ml", IValidationContext()+" context")» {
        if (!super.«validateSelf("ml", "context")») {
            return STOP_VALIDATION;
        }
        «EXPAND ValidationRule::validate FOREACH validationRules-»
        return CONTINUE_VALIDATION;
    }

    /**
     * «localizedJDoc("VALIDATE_DEPENDANTS", name)»
     * 
     * @generated
     */
	@Override
    public void «validateDependants(MessageList()+" ml", IValidationContext()+" context")» {
        super.«validateDependants("ml", "context")»;
        «EXPAND PolicyCmptAssociation::validateDependents FOREACH associations-»
    }
«ENDDEFINE»
