«IMPORT org::faktorips::devtools::stdbuilder»
«IMPORT org::faktorips::devtools::core::builder::naming»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::template»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::MethodNames»
«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::CommonGeneratorExtensions»

«DEFINE main FOR XPolicyCmptClass»
	«FILE getFileName(BuilderAspect::IMPLEMENTATION)-»
	package «packageName»;

		«EXPAND CommonDefinitions::ImportBlock FOREACH modelContext.imports ONFILECLOSE»
	
		/**
		 «IF generatingPublishedInterfaces-»
		 *	«localizedJDoc("CLASS", getSimpleName(BuilderAspect::INTERFACE))»
		 «ENDIF-»
		 * @generated
		 */
		 «getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS)-»
		public «abstract()» class «className» extends «superclassName-» «EXPAND CommonDefinitions::implementedInterfaces-»
		{

		«FOREACH attributes AS this-»
			«IF !published-»
				«EXPAND PolicyCmptAttribute::constantForPropertyName-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«FOREACH attributes AS this-»
			«IF constant-»
				«EXPAND PolicyCmptAttribute::memberField-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«EXPAND PropertyChangeSupport::fieldDefinition-»

		«FOREACH attributes AS this-»
			«IF !constant-»
				«EXPAND PolicyCmptAttribute::memberField-»
			«ENDIF-»
		«ENDFOREACH-»
			
		«EXPAND constructors»

		«FOREACH attributes AS this-»
			«EXPAND PolicyCmptAttribute::allowedValuesMethod-»
			«EXPAND PolicyCmptAttribute::getter-»
			«EXPAND PolicyCmptAttribute::setter-»
		«ENDFOREACH-»

		«IF configured-»
			«EXPAND generalMethodsForConfiguredPolicyCmpts-»
	    «ENDIF-»
	   
		«EXPAND PropertyChangeSupport::generalMethods-»
		
		«EXPAND generalMethods-»

		}
	«ENDFILE»
«ENDDEFINE»

«DEFINE constructors FOR XPolicyCmptClass-»
	/**
     * «localizedJDoc("CONSTRUCTOR", className)»
     * 
     * @generated
     */
    public «className»() {
        super();
        «EXPAND initializationForOverrideAttributes-»
    }
    «IF configured»
	/**
     * «localizedJDoc("CONSTRUCTOR", className)»
     * 
     * @generated
     */
    public «className»(«productComponentClassOrInterfaceName» productCmpt) {
        super(productCmpt);
        «EXPAND initializationForOverrideAttributes-»
    }
    «ENDIF»
«ENDDEFINE»


«DEFINE initializationForOverrideAttributes FOR XPolicyCmptClass-»
	«FOREACH attributes AS this-»
		«IF generateDefaultInitialize-»
			«methodNameSetter»(«defaultValueCode»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE generalMethodsForConfiguredPolicyCmpts FOR XPolicyCmptClass-»
		
    /**
     * «localizedJDoc("METHOD_INITIALIZE")»
     * 
     * @restrainedmodifiable
     */
	 «overrideAnnotation(false)»
    public void «initialize()» {
    	«IF hasSupertype()-»
	        super.«initialize()»;
    	«ELSE-»
	        if («methodNameGetProductCmptGeneration»() == null) {
	            return;
	        }
	        «FOREACH attributes AS this-»
				«EXPAND PolicyCmptAttribute::initConfigurableAttribute-»
	        «ENDFOREACH-»
        «ENDIF-»
	    // begin-user-code
	    // end-user-code
    }
	 
	/**
	 * {@inheritDoc}
	 *
	 * @generated
	 */
	 «overrideAnnotation(false)»
	 public «productComponentClassOrInterfaceName» «methodNameGetProductComponent»() {
	 	return («productComponentClassOrInterfaceName») «getProductComponent()»;
	 }
	 
	/**
	 * {@inheritDoc}
	 *
	 * @generated
	 */
	 «overrideAnnotation(false)»
	 public «productGenerationClassOrInterfaceName» «methodNameGetProductCmptGeneration»() {
	 	return («productGenerationClassOrInterfaceName») «getProductCmptGeneration()»;
	 }

	/**
	 * {@inheritDoc}
	 *
	 * @generated
	 */
	 «overrideAnnotation(false)»
	 public void «methodNameSetProductComponent»(«productComponentClassOrInterfaceName» «productComponentArgumentName», boolean initPropertiesWithConfiguratedDefaults) {
        «setProductComponent(productComponentArgumentName)»;
        if (initPropertiesWithConfiguratedDefaults) {
            «initialize()»;
        }
	 }
	 /**
	 * {@inheritDoc}
	 *
     * @generated
     */
	 «overrideAnnotation(false)»
    public void «effectiveFromHasChanged()» {
        super.«effectiveFromHasChanged()»;
    }
    
	/**
	 * {@inheritDoc}
	 *
	 * @generated
	 */
	 «overrideAnnotation(false)»
	 public «Calendar()» «getEffectiveFromAsCalendar()» {
	 	«IF aggregateRoot-»
		 	«IF hasSupertype()-»
		 		return super.«getEffectiveFromAsCalendar()»;
		 	«ELSE-»
		 	    return null; // TODO Implement access to effective from.
        // To avoid that the generator overwrites the implementation,
        // you have to add NOT after @annotation in the Javadoc!
		 	«ENDIF-»
		 «ELSE-»
		        «IModelObject()» parent = «getParentModelObject()»;
		        if (parent instanceof «IConfigurableModelObject()») {
		            return ((«IConfigurableModelObject()»)parent).«getEffectiveFromAsCalendar()»;
		        }
		        return null;
		 «ENDIF-»
	 }
    
«ENDDEFINE»

«DEFINE generalMethods FOR XPolicyCmptClass-»
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
	 «overrideAnnotation(false)»
    protected void «initPropertiesFromXml(Map("String", "String")+" propMap", IRuntimeRepository()+" productRepository")» {
        super.«initPropertiesFromXml("propMap", "productRepository")»;
        «FOREACH attributes AS this-»
			«EXPAND PolicyCmptAttribute::initAttributeFromXML-»
        «ENDFOREACH-»
    }
    
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    «overrideAnnotation(false)»
    protected «AbstractModelObject()» «createChildFromXml("Element childEl")» {
        «AbstractModelObject()» newChild = super.«createChildFromXml("childEl")»;
        if (newChild != null) {
            return newChild;
        }
        return null;
    }

	«IF generateDeltaSupport-»
    	«EXPAND DeltaSupport::computeDeltaMethod-»
    «ENDIF-»

    «IF generateCopySupport-»
    	«EXPAND CopySupport::copyMethods-»
    «ENDIF-»

«REM»
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    @Override
    public boolean accept(IModelObjectVisitor visitor) {
        if (!visitor.visit(this)) {
            return false;
        }
        return true;
    }

    /**
     * Validates the object (but not its children). Returns <code>true</code> if this object should
     * continue validating, <code>false</code> else.
     * 
     * @generated
     */
    @Override
    public boolean validateSelf(MessageList ml, IValidationContext context) {
        if (!super.validateSelf(ml, context)) {
            return STOP_VALIDATION;
        }
        return CONTINUE_VALIDATION;
    }

    /**
     * Validates the objects children.
     * 
     * @generated
     */
    @Override
    public void validateDependants(MessageList ml, IValidationContext context) {
        super.validateDependants(ml, context);
    }
    «ENDREM»
«ENDDEFINE»
