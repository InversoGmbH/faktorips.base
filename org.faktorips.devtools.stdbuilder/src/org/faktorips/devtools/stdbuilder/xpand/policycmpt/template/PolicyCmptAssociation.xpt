«IMPORT org::faktorips::devtools::stdbuilder»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::template»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::policycmpt::template::PolicyCmptAssociationExtension»

«DEFINE field FOR XPolicyAssociation-»
	«IF generateField-»
		«IF masterToDetail || typeAssociation-»
		    /**
		     * «localizedJDoc("FIELD_ASSOCIATION", name)»
		     * 
		     * @generated
		     */
			«IF oneToMany-»
				«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_ASSOCIATION)-»
			«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_TRANSIENT_FIELD)-»
				private «List_(targetInterfaceName)» «field(fieldName)»  = new «ArrayList(targetInterfaceName)»();
			«ELSE-»
				«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_ASSOCIATION)-»
			«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_TRANSIENT_FIELD)-»
				private «targetClassName» «field(fieldName)» = null;
			«ENDIF-»
		«ELSEIF compositionDetailToMaster-»
			/**
			 * «localizedJDoc("FIELD_PARENT", targetClassName)»
			 *
			 * @generated	 
			 */
			«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_ASSOCIATION)-»
			«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_TRANSIENT_FIELD)-»
			private «targetClassName» «field(fieldName)»;
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»
	
«DEFINE methods FOR XPolicyAssociation-»
	«EXPAND Association::getNumOf-»
	«EXPAND contains-»
	«EXPAND getters-»
	«EXPAND setterMethodsForToOne-»
	«EXPAND newChildMethods-»
	«EXPAND add-»
	«EXPAND remove-»
«ENDDEFINE»

«DEFINE contains FOR XAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
     	«overrideAnnotationForPublishedMethod()-»
	    public boolean «method(methodNameContains, targetInterfaceName, "objectToTest")» {
	    	«IF derivedUnion-»
		        return «methodNameGetter»().contains(objectToTest);
	    	«ELSE-»
		        return «fieldName».contains(objectToTest);
	    	«ENDIF-»
	    }
    «ENDIF»
«ENDDEFINE»

«DEFINE getters FOR XPolicyAssociation-»
	«IF generateGetter»
		«IF oneToMany-»
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
		    «overrideAnnotation(true)-»
		    public «List_(targetInterfaceName)» «method(methodNameGetter)» {
		        return «Collections()».unmodifiableList(«fieldName»);
		    }
		
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
		    «overrideAnnotation(true)-»
		    public «targetInterfaceName» «method(methodNameGetSingle, "int", "index")» {
		        return «fieldName».get(index);
		    }
	    «ELSE-»
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
		    «overrideAnnotation(true)-»
		    public «targetInterfaceName» «method(methodNameGetter)» {
		        return «fieldName»;
		    }
	    «ENDIF-»
    «ENDIF»
    «IF generateQualifiedGetter»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotationForPublishedMethod()»
	     «IF oneToManyIgnoringQualifier-»
		    public  «List_(targetInterfaceName)» «method(methodNameGetSingle, targetProductCmptInterfaceName, "qualifier")» {
		        if (qualifier == null) {
		            return null;
		        }
		        «IF derived-»
			        «List_(targetInterfaceName)» elements = «methodNameGetter»();
			        «List_(targetInterfaceName)» result = new  «ArrayList(targetInterfaceName)»();
			        for («targetInterfaceName» element : elements) {
			        	«LET targetPolicyCmptClass AS targetClass-»
			            if (element.«targetClass.methodNameGetProductComponent»().equals(qualifier)) {
			                result.add(element);
			            }
			            «ENDLET-»
			        }
	«REM»FIPS-1142::remove this if-else«ENDREM»	        «ELSE-»
			        «List_(targetInterfaceName)» result = new  «ArrayList(targetInterfaceName)»();
			        for («targetInterfaceName» «targetClassName.toFirstLower()» : «fieldName») {
			        	«LET targetPolicyCmptClass AS targetClass-»
			            if («targetClassName.toFirstLower()».«targetClass.methodNameGetProductComponent»().equals(qualifier)) {
			                result.add(«targetClassName.toFirstLower()»);
			            }
			            «ENDLET-»
			        }
		        «ENDIF-»
		        return result;
		    }
		«ELSE-»
		    public  «targetInterfaceName» «method(methodNameGetSingle, targetProductCmptInterfaceName, "qualifier")» {
		        if (qualifier == null) {
		            return null;
		        }
		        «IF derived-»
			        «List_(targetInterfaceName)» elements = «methodNameGetter»();
			        for («targetInterfaceName» element : elements) {
			        	«LET targetPolicyCmptClass AS targetClass-»
			            if (element.«targetClass.methodNameGetProductComponent»().equals(qualifier)) {
			                return element;
			            }
			            «ENDLET-»
			        }
	«REM»FIPS-1142::remove this if-else«ENDREM»	        «ELSE-»
			        for («targetInterfaceName» «targetClassName.toFirstLower()» : «fieldName») {
			        	«LET targetPolicyCmptClass AS targetClass-»
			            if («targetClassName.toFirstLower()».«targetClass.methodNameGetProductComponent»().equals(qualifier)) {
			                return «targetClassName.toFirstLower()»;
			            }
			            «ENDLET-»
			        }
		        «ENDIF-»
		        return null;
		    }
		«ENDIF-»
	«ENDIF»
«ENDDEFINE»

«DEFINE setterMethodsForToOne FOR XPolicyAssociation-»
	«IF generateSetter-»
		«IF compositionDetailToMaster-»
			«IF !sharedAssociationImplementedInSuperclass-»
				/**
			     * @generated
			     */
			    public void «method(methodNameSetInternal,targetInterfaceName, "newParent")» {
			        if («methodNameGetter»() == newParent) {«REM»parent association can only be 1to1. getSingle can be used.«ENDREM»
			            return;
			        }
			        «IModelObject()» «parentVar()» = «getParentModelObject()»;
			        if (newParent != null && «parentVar()» != null) {
			            throw new «RuntimeException()»(«localizedText("RUNTIME_EXCEPTION_SET_PARENT_OBJECT_INTERNAL", typeName, name)»);
			        }
			        this.«fieldName» = «EXPAND castToImplementationIfNecessary» newParent;
			        «IF typeConfigurableByProductCmptType-»
			        	effectiveFromHasChanged();
					«ENDIF-»
			    }
			«ENDIF-»
		«ELSE-»
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
		    «overrideAnnotation(true)-»
		    public void «method(methodNameSetter, targetInterfaceName, "newObject")» {
		    	«IF generateChangeSupport-»
					«EXPAND PropertyChangeSupport::storeOldValue-»
			        «methodNameSetInternal»(newObject);
					«EXPAND PropertyChangeSupport::notify-»
				«ELSE-»
					«EXPAND setterMethodCode-»
				«ENDIF-»
		    }
	
	    	«IF generateChangeSupport-»
			    /** «REM»TODO old codegenerator writes the comment only for compositions«ENDREM»
			     «IF !typeAssociation-» 
			     * «localizedJDoc("METHOD_SET_OBJECT_INTERNAL", name)»
			     * 
			     «ENDIF-»
			     * @generated
			     */
			    public void «method(methodNameSetInternal, targetInterfaceName, "newObject")»{
					«EXPAND setterMethodCode-»
		    	}	
			«ENDIF-»
		«ENDIF-»
    «ENDIF-»
«ENDDEFINE»

«DEFINE setterMethodCode FOR XPolicyAssociation-»
	«IF masterToDetail-»
		«IF generateCodeToSynchronizeInverseCompositionForSet-»
	        if («fieldName» != null) {
	            «EXPAND synchronizeInverseCompositionIfNecessaryForSet(false, fieldName, "null")-»
	        }
	        if (newObject != null) {
	            «EXPAND synchronizeInverseCompositionIfNecessaryForSet(true, "newObject", "this")-»
	        }
        «ENDIF-»
        «fieldName» = «EXPAND castToImplementationIfNecessary» newObject;
    	«EXPAND synchronizeInverseAssociationIfNecessary(fieldName)-»
    «ENDIF-»
    «IF typeAssociation-»
    	if (newObject == «fieldName») return;
    	«IF hasInverseAssociation()-»
	        «targetInterfaceName» oldRefObject = «fieldName»;
	        «fieldName» = null;
	        «EXPAND cleanupOldReference("oldRefObject")-»
	    «ENDIF-»
        «fieldName» = «EXPAND castToImplementationIfNecessary» newObject;
    	«EXPAND synchronizeInverseAssociationIfNecessary(fieldName)-»
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseCompositionIfNecessaryForSet(boolean cast, String varName, String newRef) FOR XPolicyAssociation-»
	«IF cast»«EXPAND castIfNeccessary(varName)»«ELSE»«varName»«ENDIF».«inverseAssociation.methodNameSetInternal»(«newRef»);
«ENDDEFINE»

«DEFINE cleanupOldReference(String varToCleanUp) FOR XPolicyAssociation-»
	«IF !oneToMany-»
		if(«varToCleanUp» != null){
        	«EXPAND cleanupOldReferenceInner(varToCleanUp)-»
		}
    «ELSE-»
    	«EXPAND cleanupOldReferenceInner(varToCleanUp)-»
    «ENDIF-»
«ENDDEFINE»

«DEFINE cleanupOldReferenceInner(String varToCleanUp) FOR XPolicyAssociation-»
	«IF inverseAssociation.oneToMany-»
		«varToCleanUp».«inverseAssociation.methodNameRemove»(this);
    «ELSE-»
		«varToCleanUp».«inverseAssociation.methodNameSetter»(null);    	
    «ENDIF-»
«ENDDEFINE»

«DEFINE castIfNeccessary(String varName) FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»
	(«EXPAND castToImplementationIfNecessary»«varName»)«ELSE-»
	«varName»«ENDIF-»
«ENDDEFINE»

«DEFINE castToImplementationIfNecessary FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»(«targetClassName»)«ENDIF-»
«ENDDEFINE»

«DEFINE newChildMethods FOR XPolicyAssociation-»
	«IF generateNewChildMethods-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameNew)»{
	        «targetClassName» «variableNameNewInstance» = new «targetClassName»();
			«EXPAND addOrSetNewInstance-»
	        «variableNameNewInstance».«initialize()»;
	        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
	        return «variableNameNewInstance»;
	    }
	
		«IF generateNewChildWithArgumentsMethod-»
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
			«overrideAnnotation(true)»
		    public «targetInterfaceName» «method(methodNameNew, targetProductCmptInterfaceName, targetProductCmptVariableName)» {
		        if («targetProductCmptVariableName» == null) {
		            return «methodNameNew»();
		        }
		        «targetInterfaceName» «variableNameNewInstance» = «targetProductCmptVariableName».«methodNameCreatePolicyCmptForTargetProductCmpt»(); 
				«EXPAND addOrSetNewInstance-»
		        «variableNameNewInstance».«initialize()»;
		        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
		        return «variableNameNewInstance»;
		    }
	    «ENDIF-»
    «ENDIF-»
«ENDDEFINE»

«DEFINE addOrSetNewInstance FOR XPolicyAssociation-»
	«IF oneToMany-»
       	«methodNameAddInternal»(«variableNameNewInstance»);
    «ELSE-»
       	«methodNameSetInternal»(«variableNameNewInstance»);
    «ENDIF-»
«ENDDEFINE»

«DEFINE add FOR XPolicyAssociation-»
	«IF generateAddAndRemoveMethod-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameAdd, targetInterfaceName, "objectToAdd")»{
	        «methodNameAddInternal»(objectToAdd);
	        «EXPAND PropertyChangeSupport::notifyNewAssociation("objectToAdd")-»
	    }
	
	    /**
	     * «localizedJDoc("METHOD_ADD_OBJECT_INTERNAL", name)»
	     * 
	     * @generated
	     */
	    public void «method(methodNameAddInternal, targetInterfaceName, "objectToAdd")»{
	        if (objectToAdd == null) {
	            throw new NullPointerException("Can't add null to association «name» of " + this);
	        }
	        if («fieldName».contains(objectToAdd)) {
	            return;
	        }
	        «EXPAND synchronizeInverseCompositionIfNecessaryForAdd-»
			«fieldName».add(objectToAdd);
	        «EXPAND synchronizeInverseAssociationIfNecessary("objectToAdd")-»
	    }
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseCompositionIfNecessaryForAdd FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForAdd-»
		«EXPAND castIfNeccessary("objectToAdd")».«inverseAssociation.methodNameSetInternal»(this);
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseAssociationIfNecessary(String objectToSynchronize) FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseAssociation-»
		«IF inverseAssociation.oneToMany-»
			if («EXPAND varNameNullCheckIfNecessary(objectToSynchronize)» !«objectToSynchronize».«inverseAssociation.methodNameContains»(this)) {
				«objectToSynchronize».«inverseAssociation.methodNameAdd»(this);
			}
	    «ELSE-»
	    	if («EXPAND varNameNullCheckIfNecessary(objectToSynchronize)» «objectToSynchronize».«inverseAssociation.methodNameGetter»() != this) {
				«IF false-»
				«REM» 
					TODO unnötiger Cast und Fallunterscheidung!
					«EXPAND castIfNeccessary(objectToSynchronize)»
				«ENDREM»
				«ENDIF-»
				«IF oneToMany-»
					«EXPAND castIfNeccessary(objectToSynchronize)».«inverseAssociation.methodNameSetter»(this);
				«ELSE-»
					«objectToSynchronize».«inverseAssociation.methodNameSetter»(this);
				«ENDIF-»
			}
	    «ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE varNameNullCheckIfNecessary(String varName) FOR XPolicyAssociation-»
	«IF !oneToMany-»
		«varName» !=null &&
	«ENDIF-»
«ENDDEFINE»

«DEFINE remove FOR XPolicyAssociation-»
	«IF generateAddAndRemoveMethod-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameRemove, targetInterfaceName, "objectToRemove")»{
	        if (objectToRemove == null) {
	            return;
	        }
			«EXPAND removeAndDetach-»
	        «EXPAND PropertyChangeSupport::notifyRemovedAssociation("objectToRemove")-»
	    }
    «ENDIF-»
«ENDDEFINE»

«DEFINE removeAndDetach FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForRemove-»
		if («fieldName».remove(objectToRemove)) {
			«EXPAND detachRemovedObject-»
		}
	«ELSE-»
		«fieldName».remove(objectToRemove);
	«ENDIF-»
«ENDDEFINE»

«REM» TODO FIPS-1141 (7): delete the «IF hasInverseAssociation()-» clause when fixed«ENDREM»
«DEFINE detachRemovedObject FOR XPolicyAssociation-»
	«IF hasInverseAssociation()-»
		«IF inverseAssociation.oneToMany-»
			objectToRemove.«inverseAssociation.methodNameRemove»(this);
		«ELSE-»
			«IF inverseAssociation.typeAssociation-»
				«EXPAND castIfNeccessary("objectToRemove")».«inverseAssociation.methodNameSetter»(null);
			«ELSE-»
				«EXPAND castIfNeccessary("objectToRemove")».«inverseAssociation.methodNameSetInternal»(null);
			«ENDIF-»
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE delegateEffectiveFromHasChanged FOR XPolicyAssociation-»
	«IF considerInEffectiveFromHasChanged-»
		«IF oneToMany-»
			for («Iterator(targetInterfaceName)» it = «fieldName».iterator(); it.hasNext();) {
	            «AbstractConfigurableModelObject()» child = («AbstractConfigurableModelObject()»)it.next();
	            child.effectiveFromHasChanged();
	        }
		«ELSE-»
			if («fieldName» != null) {
	            ((«AbstractConfigurableModelObject()»)«fieldName»).effectiveFromHasChanged();
	        }
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE validateDependents FOR XPolicyAssociation-»
	«IF considerInValidateDependents-»
        «IF oneToMany-»
	        if («methodNameGetNumOf»() > 0) {
	            for («targetInterfaceName» rel : «methodNameGetter»()) {
	                ml.add(rel.validate(context));
	            }
	        }
        «ELSE-»
        	if («fieldName» != null) {
	            ml.add(«fieldName».validate(context));
	        }
        «ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE createTargetFromXML FOR XPolicyAssociation-»
	«IF considerInCreateChildFromXML-»
        if ("«name»".equals(childEl.getNodeName())) {
            String className = childEl.getAttribute("class");
            if (className.length() > 0) {
                try {
                    «targetClassName» «createChildFromXMLLocalVarName» = («targetClassName»)Class.forName(className).newInstance();
                    «IF oneToMany-»
	                    «methodNameAdd»(«createChildFromXMLLocalVarName»);
                    «ELSE-»
	                    «methodNameSetter»(«createChildFromXMLLocalVarName»);                    	
                    «ENDIF-»
                    return «createChildFromXMLLocalVarName»;
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            «IF abstractTarget-»
            	throw new RuntimeException(childEl.toString() + ": Attribute className is missing.");
            «ELSE-»
            	return («AbstractModelObject()»)«methodNameNew»();
            «ENDIF-»
        }
	«ENDIF-»
«ENDDEFINE»

«DEFINE createUnresolvedReference FOR XPolicyAssociation-»
	«IF considerInCreateCreateUnresolvedReference-»
		if ("«name»".equals(targetRole)) {
            return new «DefaultUnresolvedReference()»(this, objectId, "«IF oneToMany»«methodNameAdd»«ELSE»«methodNameSetter»«ENDIF-»",
                    «targetInterfaceName».class, targetId);
        }
	«ENDIF-»
«ENDDEFINE»

        
