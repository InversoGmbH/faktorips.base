PersistentAssociationInfo_joinColumnName=join column name
PersistentAssociationInfo_joinTableName=join table name
PersistentAssociationInfo_msgIsInvalid={0} is invalid.
PersistentAssociationInfo_msgJoinTableNameExceedsMaximumLength=The join table name length exceeds the maximum length defined in the persistence options. The join table name length is {0} and the maximum length is {1}.
PersistentAssociationInfo_msgLazyFetchNotSupported=The lazy fetch type is not supported on single valued associations sides.
PersistentAssociationInfo_msgMaxLengthExceeds=The {0} length exceeds the maximum length defined in the persistence options. The length is {1} and the maximum column length is {2}.
PersistentAssociationInfo_msgMustBeEmpty=The {0} must {1} be empty
PersistentAssociationInfo_msgNot=\ not
PersistentAssociationInfo_msgOwningSideManyToManyMarkedOnBothSides=The owning side of the relationship is marked on both sides.
PersistentAssociationInfo_msgOwningSideManyToManyNotAllowed=Must not be marked as owning side of many-to-many association because an join table is not required.
PersistentAssociationInfo_msgOwningSideMissing=At least one assocition must be marked as the owning side of the relationship.
PersistentAssociationInfo_msgTransientMismatch=If the association is marked as transient or if the persistent type is not entity, then the target side must also be marked as transient and vise versa.
PersistentAssociationInfo_msgWarningManualyCodeMergeNecessary=It is necessary to fix the annotation manually on the field '{0}' in the corresponding java class, because the merging of annotaion changes in java code doesn't work correctly yet.
PersistentAssociationInfo_sourceColumnName=source column name
PersistentAssociationInfo_tagetColumnName=target column name
PersistentAttributeInfo_msgColumnNameLengthExceedsMaximumLength=The column name length exceeds the maximum length defined in the persistence options. The column name length is {0} and the maximum defined length is {1}.
PersistentAttributeInfo_msgColumnPrecisionExceedsTheLimit=The column precision exceeds the limit [{0}..{1}]
PersistentAttributeInfo_msgColumnScaleExceedsTheLimit=The column scale exceeds the limit [{0}..{1}]
PersistentAttributeInfo_msgColumnSizeExceedsTheLimit=The column size exceeds the limit [{0}..{1}]
PersistentAttributeInfo_msgEmptyColumnName=Empty column name.
PersistentTypeInfo_msgDiscriminatorAlreadyDefined=The discriminator value "{0}" is already defined in the supertype {1}
PersistentTypeInfo_msgDiscriminatorColumnNameIsInvalid=The discriminator column name is invalid.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedBecauseMappedSuperclass=The discriminator definition is not allowed here because this type is marked as mapped superclass.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedNotRootEntity=The discriminator definition is not allowed here because this type is not the root entity.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedTypeNotDefDiscrColumn=The discriminator definition is not allowed here because this type doesn't define the discriminator column.
PersistentTypeInfo_msgDiscriminatorMustBeDefinedInTheRootEntity=The discriminator must be defined in the root entity {0}.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmpty=The discriminator value must be empty if the root entity doesn't define a discriminator column or the type is abstract.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmptyBecauseMappedSuperclass=The discriminator value must be empty because this type is marked as mapped superclass.
PersistentTypeInfo_msgDiscriminatorValueMustNotBeEmpty=The discriminator value must not be empty if the root entity defines the dicriminator column and the type is not abstract.
PersistentTypeInfo_msgDiscriminatorValueNotConform=The discriminator value does not conform to the specified descriminator datatype.
PersistentTypeInfo_msgDuplicateColumnName=Duplicate column name {0}
PersistentTypeInfo_msgFoundDuplicateColumnNameIn=. Found duplicate name in {0}.
PersistentTypeInfo_msgInvalidInheritanceStratedyCombination=Invalid combination of inheritance strategies. Resolve by changing strategy for either {0} ({1}) or {2} ({3})
PersistentTypeInfo_msgTableNameExceedsMaximumLength=The table name length exceeds the maximum length defined in the persistence options. The table name length is {0} and the maximum length is {1}.
PersistentTypeInfo_msgTableNameInvalid=The table name is invalid
PersistentTypeInfo_msgTableNameMustBeEmptyBecauseNameDefinedInSupertypeShouldBeUsed=The table name must be empty because the table name defined in the super type should be used.
PersistentTypeInfo_msgTableNameMustBeEmptyMappedSuperclass=The table name must empty because the policy component type is marked as mapped superclass.
PersistentTypeInfo_msgTableNameMustBeEmptyNotRootEntityAndInhStrategyIs=The table name must be empty because this is not the root entity and the inheritance strategy is: {0}
PersistentTypeInfo_msgTableNameOfRootEntityMustBeUsed=The table name of the root entity must be used because this is not the root entity and the inheritance strategy is: {0}
PersistentTypeInfo_msgUseTableDefInSupertypIsNotAllowed=No supertype specified, thus it is not possible to use the table defined in the supertyp.
PolicyCmptType_productCmptType=Product component type
PolicyCmptType_msg_ProductCmptTypeNameMissing=The product component type name is missing.
PolicyCmptType_TheTypeDoesNotConfigureThisType=The type {0} does not configure this type.
PolicyCmptType_msg_IfTheSupertypeIsNotConfigurableTheTypeCanBeConfigurable=If the supertype is not configurable, the type can't be.
PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmpty=For detail-to-master associations the inverse associations must not be empty
PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmptyIfDerivedUnionHasInverse=The inverse must not be empty, if the derived union association specifies an inverse association.
PolicyCmptTypeAssociation_Association_msg_InverseOfMasterToDetailMustBeADetailToMaster=The inverse of a master-to-detail association must be a detail-to-master association.
PolicyCmptTypeAssociation_InverseOfDetailToMasterMustBeAMasterToDetail=The inverse of a detail-to-master association must be a master-to-detail association.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureIsMissing=The reference to the computation method signature is missing for attribute {0}\!
PolicyCmptTypeAttribute_TypeOfOverwrittenAttributeCantBeChanged=The type of the overwritten attribute can't be changed\!
PolicyCmptType_msgSubtypeConfigurableWhenSupertypeConfigurable=The super type is configurable which means this type needs to be configurable as well.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureDoesNotExists=The specified computation method signature does not exist\!
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureHasADifferentDatatype=The computation method has a different datatype\!
Association_msg_InverseAssociationInconsistentWithDerivedUnion=The inverse association is inconsistent with the derived union {0}.
Association_msg_AssociationNotFoundInTarget=The association {0} does not exist in the target {1}.
Association_msg_InverseAssociationMismatch=The inverse relation does not specify this relation as it's inverse one\!
Association_msg_InverseAssociationMustBeMarkedAsDerivedUnionToo=The association and it's inverse association must both be marked as derived union.
Association_msg_InverseAssociationMustBeOfTypeAssociation=The inverse association of an association must be an association\!
Association_msg_DetailToMasterAssociationMustHaveMaxCardinality1=A detail-to-master association must have a max cardinality of 1.
ValidationRule_msgFunctionNotExists=Function {0} does not exists.
ValidationRule_msgIgnored=The rule is applied in all business functions, this information is ignored.
ValidationRule_msgUndefinedAttribute=The specified attribute is not defined for the policy component type of this rule.
ValidationRule_msgOneBusinessFunction=If the validation rule is not applied to all business functions, at least one business function must be assigned.
ValidationRule_msgCodeShouldBeProvided=A message code should be provided to make testing of the rule easier for example.
ValidationRule_ConstantAttributesCantBeValidated=Constant attributes can't be validated\!
ValidationRule_msgDuplicateEntries=Duplicate entries.
ValidationRule_msgNoNewlineAllowed=No newline allowed in message text.
ValidationRule_msgValueSetRule=The value set of this attribute needs to be either a range or an enumeration to enable this rule. 
Attribute_msgAttributeCantBeProductRelevantIfTypeIsNot=The attribute can only be configured, if the owning type is configurable.
Attribute_msgNothingToOverwrite=No attribute {0} in supertype hierarchy, so nothing can be overwritten.
Attribute_proposalForMsgCode=INVALID_{0}
Attribute_proposalForRuleName=check{0}
