/*******************************************************************************
  * Copyright (c) 2005,2006 Faktor Zehn GmbH und andere.
  *
  * Alle Rechte vorbehalten.
  *
  * Dieses Programm und alle mitgelieferten Sachen (Dokumentationen, Beispiele,
  * Konfigurationen, etc.) duerfen nur unter den Bedingungen der 
  * Faktor-Zehn-Community Lizenzvereinbarung - Version 0.1 (vor Gruendung Community) 
  * genutzt werden, die Bestandteil der Auslieferung ist und auch unter
  *   http://www.faktorips.org/legal/cl-v01.html
  * eingesehen werden kann.
  *
  * Mitwirkende:
  *   Faktor Zehn GmbH - initial API and implementation - http://www.faktorzehn.de
  *
  *******************************************************************************/

package org.faktorips.devtools.core.builder;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.OperationCanceledException;
import org.faktorips.devtools.core.IpsPlugin;
import org.faktorips.devtools.core.IpsStatus;
import org.faktorips.devtools.core.internal.model.IpsModel;
import org.faktorips.devtools.core.model.IIpsArtefactBuilder;
import org.faktorips.devtools.core.model.IIpsArtefactBuilderSet;
import org.faktorips.devtools.core.model.IIpsElement;
import org.faktorips.devtools.core.model.IIpsObject;
import org.faktorips.devtools.core.model.IIpsPackageFragment;
import org.faktorips.devtools.core.model.IIpsPackageFragmentRoot;
import org.faktorips.devtools.core.model.IIpsProject;
import org.faktorips.devtools.core.model.IIpsSrcFile;
import org.faktorips.devtools.core.model.QualifiedNameType;
import org.faktorips.util.message.Message;
import org.faktorips.util.message.MessageList;

/**
 * The ips builder generates Java sourcecode and xml files based on the ips
 * objects contained in the ips project. It runs before the Java builder, so
 * that first the Java sourcecode is generated by the ips builder and then the
 * Java builder compiles the Java sourcecode into classfiles.
 */
public class IpsBuilder extends IncrementalProjectBuilder {

	/**
	 * The builders extension id.
	 */
	public final static String BUILDER_ID = IpsPlugin.PLUGIN_ID + ".ipsbuilder"; //$NON-NLS-1$

	private static boolean lastBuildWasCancelled = false;

	public IpsBuilder() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	protected IProject[] build(int kind, Map args, IProgressMonitor monitor)
			throws CoreException {

		MultiStatus buildStatus = null;
		if (lastBuildWasCancelled) {
			lastBuildWasCancelled = false;
			return getProject().getReferencedProjects();
		}
		getProject().deleteMarkers(IpsPlugin.PROBLEM_MARKER, true, 0);
		MessageList list = getIpsProject().validate();
		createMarkersFromMessageList(getProject(), list,
				IpsPlugin.PROBLEM_MARKER);
		if (!getIpsProject().canBeBuild()) {
			IMarker marker = getProject()
					.createMarker(IpsPlugin.PROBLEM_MARKER);
			String msg = Messages.IpsBuilder_msgInvalidProperties;
			updateMarker(marker, msg, IMarker.SEVERITY_ERROR);
			return getProject().getReferencedProjects();
		}
		buildStatus = applyBuildCommand(buildStatus,
				new BeforeBuildProcessCommand(kind));
		if (kind == IncrementalProjectBuilder.FULL_BUILD
				|| kind == IncrementalProjectBuilder.CLEAN_BUILD
				|| getDelta(getProject()) == null) {
			// delta not available
			buildStatus = fullBuild(monitor);
		} else {
			buildStatus = incrementalBuild(monitor);
		}
		buildStatus = applyBuildCommand(buildStatus,
				new AfterBuildProcessCommand(kind));
		
		if (buildStatus.getSeverity() == IStatus.OK) {
			return getProject().getReferencedProjects();
		}

		// reinitialize the builders of the current builder set if an error
		// occurs
		try {
			IIpsArtefactBuilderSet builderSet = getIpsProject()
					.getArtefactBuilderSet();
			builderSet.initialize();
		} catch (Exception e) {
			buildStatus.add(new IpsStatus(
					Messages.IpsBuilder_msgErrorExceptionDuringBuild));
		}
		throw new CoreException(buildStatus);
	}

	private MultiStatus applyBuildCommand(MultiStatus buildStatus,
			BuildCommand command) throws CoreException {
		// Despite the fact that generating is disabled in the faktor ips
		// preferences the
		// validation of the modell class instances and marker updating of the
		// regarding resource files still takes place
		if (!IpsPlugin.getDefault().getIpsPreferences().getEnableGenerating()) {
			return buildStatus;
		}
		IIpsArtefactBuilderSet currentBuilderSet = getIpsProject()
				.getArtefactBuilderSet();
		IIpsArtefactBuilder[] artefactBuilders = currentBuilderSet
				.getArtefactBuilders();
		for (int i = 0; i < artefactBuilders.length; i++) {
			try {
				command.build(artefactBuilders[i], buildStatus);
			} catch (Exception e) {
				return addIpsStatus(artefactBuilders[i], command, buildStatus,
						e);
			}
		}
		return buildStatus;
	}

	private MultiStatus addIpsStatus(IIpsArtefactBuilder builder,
			BuildCommand command, MultiStatus buildStatus, Exception e) {
		MultiStatus returnStatus = buildStatus;
		if (returnStatus == null) {
			returnStatus = new MultiStatus(IpsPlugin.PLUGIN_ID, 0,
					"Build Results", null); //$NON-NLS-1$
		}
		String text = builder.getName() + ": Error during: " + command + "."; //$NON-NLS-1$ //$NON-NLS-2$
		returnStatus.add(new IpsStatus(text, e));
		return returnStatus;
	}

	private DependencyGraph getDependencyGraph() throws CoreException {
		IpsModel model = ((IpsModel) getIpsProject().getIpsModel());
		return model.getDependencyGraph(getIpsProject());
	}

	/*
	 * Returns the ips project the build is currently building.
	 */
	private IIpsProject getIpsProject() {
		return IpsPlugin.getDefault().getIpsModel().getIpsProject(getProject());
	}

	/**
	 * Full build generates Java source files for all IPS objects.
	 */
	private MultiStatus fullBuild(IProgressMonitor monitor) {
		System.out.println("Full build started."); //$NON-NLS-1$
		long begin = System.currentTimeMillis();
		MultiStatus buildStatus = new MultiStatus(IpsPlugin.PLUGIN_ID, 0,
				Messages.IpsBuilder_msgFullBuildResults, null);

		try {
			getDependencyGraph().reInit();
			IIpsPackageFragmentRoot[] roots = getIpsProject()
					.getIpsPackageFragmentRoots();
			for (int i = 0; i < roots.length; i++) {
				IIpsPackageFragment[] packs = roots[i].getIpsPackageFragments();
				for (int j = 0; j < packs.length; j++) {
					IIpsElement[] elements = packs[j].getChildren();
					for (int k = 0; k < elements.length; k++) {
						if (elements[k] instanceof IIpsSrcFile) {
							try {
								buildIpsSrcFile((IIpsSrcFile) elements[k],
										buildStatus, monitor);
							} catch (Exception e) {
								buildStatus.add(new IpsStatus(e));
							}
						}
					}
				}
				removeEmptyFolders(roots[i].getArtefactDestination(), false,
						monitor);
			}

		} catch (CoreException e) {
			buildStatus.add(new IpsStatus(e));
		}
		long end = System.currentTimeMillis();
		System.out.println("Full build finished. Duration: " + (end - begin)); //$NON-NLS-1$
		return buildStatus;
	}

	/**
	 * {@inheritDoc}
	 */
	protected void clean(IProgressMonitor monitor) throws CoreException {
		getIpsProject().getArtefactBuilderSet().clean();
	}

	private void removeEmptyFolders(IFolder parent, boolean removeThisParent,
			IProgressMonitor monitor) throws CoreException {
		if (!parent.exists()) {
			return;
		}
		IResource[] members = parent.members();
		if (removeThisParent && members.length == 0) {
			parent.delete(true, monitor);
			return;
		}
		for (int i = 0; i < members.length; i++) {
			if (members[i].getType() == IResource.FOLDER) {
				removeEmptyFolders((IFolder) members[i], true, monitor);
			}
		}
	}

	/**
	 * Incremental build generates Java source files for all PdObjects that have
	 * been changed.
	 */
	private MultiStatus incrementalBuild(IProgressMonitor monitor) {
		System.out.println("Incremental build started."); //$NON-NLS-1$
		MultiStatus buildStatus = new MultiStatus(IpsPlugin.PLUGIN_ID, 0,
				Messages.IpsBuilder_msgIncrementalBuildResults, null);
		IResourceDelta delta = getDelta(getProject());
		try {
			IncBuildVisitor visitor = new IncBuildVisitor(buildStatus, monitor);
			delta.accept(visitor);
			buildStatus = visitor.buildStatus;
		} catch (Exception e) {
			buildStatus.add(new IpsStatus(e));
		} finally {
			System.out.println("Incremental build finished."); //$NON-NLS-1$
			monitor.done();
		}
		return buildStatus;
	}

	private void updateMarkers(IIpsObject object) throws CoreException {
		if (object == null) {
			return;
		}
		IResource resource = object.getEnclosingResource();
		if (!resource.exists()) {
			return;
		}
		resource.deleteMarkers(IMarker.PROBLEM, true, IResource.DEPTH_INFINITE);
		MessageList list = object.validate();
		createMarkersFromMessageList(resource, list, IMarker.PROBLEM);
	}

	private void createMarkersFromMessageList(IResource resource,
			MessageList list, String markerType) throws CoreException {
		for (int i = 0; i < list.getNoOfMessages(); i++) {
			Message msg = list.getMessage(i);
			IMarker marker = resource.createMarker(markerType);
			updateMarker(marker, msg.getText(), getMarkerSeverity(msg));
		}
	}

	private void updateMarker(IMarker marker, String text, int severity)
			throws CoreException {
		marker.setAttributes(
				new String[] { IMarker.MESSAGE, IMarker.SEVERITY },
				new Object[] { text, new Integer(severity) });
	}

	private int getMarkerSeverity(Message msg) {
		int msgSeverity = msg.getSeverity();
		if (msgSeverity == Message.ERROR) {
			return IMarker.SEVERITY_ERROR;
		} else if (msgSeverity == Message.WARNING) {
			return IMarker.SEVERITY_WARNING;
		} else if (msgSeverity == IMarker.SEVERITY_INFO) {
			return IMarker.SEVERITY_INFO;
		}
		throw new RuntimeException("Unknown severity " + msgSeverity); //$NON-NLS-1$
	}

	/**
	 * Builds the indicated file and updates its markers.
	 */
	private IIpsObject buildIpsSrcFile(IIpsSrcFile file,
			MultiStatus buildStatus, IProgressMonitor monitor)
			throws CoreException {
		if (!file.isContentParsable()) {
			return null;
		}
		IIpsObject ipsObject = file.getIpsObject();
		applyBuildCommand(buildStatus, new BuildArtefactBuildCommand(file));
		updateMarkers(ipsObject);
		return ipsObject;
	}

	/**
	 * Builds the indicated file, updates its markers and updates dependant
	 * IpsSrcFiles.
	 */
	private void buildIpsSrcFileIncremental(IIpsSrcFile file,
			MultiStatus buildStatus, Set toUpdate, IProgressMonitor monitor)
			throws CoreException {
		buildIpsSrcFile(file, buildStatus, monitor);
		updateDependencies(toUpdate, file, buildStatus, monitor);
		if (monitor.isCanceled()) {
			throw new OperationCanceledException();
		}
	}

	/**
	 * Deletes the indicated file and updates dependant IpsSrcFiles.
	 */
	private void deleteIpsSrcFile(IIpsSrcFile file, MultiStatus buildStatus,
			IProgressMonitor monitor) throws CoreException {
		applyBuildCommand(buildStatus, new DeleteArtefactBuildCommand(file));
		HashSet toUpdate = new HashSet();
		updateDependencies(toUpdate, file, buildStatus, monitor);
		if (monitor.isCanceled()) {
			throw new OperationCanceledException();
		}
	}

	/**
	 * Updates IpsSrcFiles that are dependant on the provided IpsSrcFile
	 * according to the dependency graph of the IpsProject the provided
	 * IpsSrcFile is in. This method calls itself recursively and keeps the
	 * <code>QualifiedNameType</code>s of the already built IpsSrcFiles in
	 * the parameter <code>toUpdate</code> to avoid uneccessary multiple
	 * builds of the same IpsSrcFile.
	 */
	private void updateDependencies(Set toUpdate, IIpsSrcFile file,
			MultiStatus buildStatus, IProgressMonitor monitor)
			throws CoreException {
		toUpdate.add(file.getQualifiedNameType());
		DependencyGraph graph = getDependencyGraph();
		buildDependants(buildStatus, file.getQualifiedNameType(), toUpdate,
				monitor, graph);
		updateDependencyGraph(toUpdate, graph);
		HashSet alreadyBuildProjects = new HashSet();
		buildDependantIpsProjects(getProject(), alreadyBuildProjects, buildStatus, file
				.getQualifiedNameType(), monitor);
	}

	/**
	 * Looks in projects that depend on the provided project for IpsSrcFiles
	 * that are dependant on the provided QualifiedNameType according to the
	 * dependency graph of the project and builds these and updates the
	 * dependancy graph of the project. This method calls itself recursively
	 * along the chain of dependant projects.
	 */
	private void buildDependantIpsProjects(IProject project, Set alreadyBuildProjects,
			MultiStatus buildStatus, QualifiedNameType nameType,
			IProgressMonitor monitor) throws CoreException {

		IProject[] dependantProjects = project.getReferencingProjects();
		
		for (int i = 0; i < dependantProjects.length && !alreadyBuildProjects.contains(dependantProjects[i]); i++) {
			IpsModel model = (IpsModel) IpsPlugin.getDefault().getIpsModel();
			DependencyGraph graph = model.getDependencyGraph(model
					.getIpsProject(dependantProjects[i]));
			if (graph == null) {
				continue;
			}
			Set alreayBuild = new HashSet();
			buildDependants(buildStatus, nameType, alreayBuild, monitor, graph);
			updateDependencyGraph(alreayBuild, graph);
			alreadyBuildProjects.add(dependantProjects[i]);
			buildDependantIpsProjects(dependantProjects[i], alreadyBuildProjects, buildStatus,
					nameType, monitor);
		}
	}

	/**
	 * Updates the provided dependency graph with the provided set of
	 * QualifiedNameTypes.
	 */
	private void updateDependencyGraph(Set toUpdate, DependencyGraph graph)
			throws CoreException {
		for (Iterator it = toUpdate.iterator(); it.hasNext();) {
			QualifiedNameType qualifiedNameType = (QualifiedNameType) it.next();
			graph.update(qualifiedNameType);
		}
	}

	/**
	 * Builds all IpsSrcFiles that are dependant on the provided
	 * QualifiedNameType according to the provided dependency graph. The
	 * QualifiedNameType of IpsSrcFiled that have been built are collected in
	 * the provided parameter <code>alreadyBuild</code>. This method calls
	 * itself recursively along the dependency chain.
	 */
	private void buildDependants(MultiStatus buildStatus,
			QualifiedNameType nameType, Set alreadyBuild,
			IProgressMonitor monitor, DependencyGraph dependencyGraph)
			throws CoreException {
		QualifiedNameType[] dependants = dependencyGraph
				.getDependants(nameType);
		for (int i = 0; i < dependants.length; i++) {
			if (!alreadyBuild.contains(dependants[i])) {
				IIpsObject dependant = dependencyGraph.getIpsProject()
						.findIpsObject(dependants[i]);
				updateMarkers(dependant);
				if (dependant != null) {
					applyBuildCommand(buildStatus,
							new BuildArtefactBuildCommand(dependant
									.getIpsSrcFile()));
				}
				alreadyBuild.add(dependants[i]);
//not longer traverse the graph recursively since the graphs edges are build based on the transitive closure		
//				buildDependants(buildStatus, dependants[i], alreadyBuild,
//						monitor, dependencyGraph);
			}
		}
	}

	/**
	 * Returns the number of entries in the delta
	 * 
	 * @throws CoreException
	 */
	protected int getWorkLoad(IResourceDelta delta) throws CoreException {
		WorkLoadVisitor visitor = new WorkLoadVisitor();
		delta.accept(visitor);
		return visitor.work;
	}

	/**
	 * ResourceDeltaVisitor for the incremental build.
	 */
	private class IncBuildVisitor implements IResourceDeltaVisitor {

		private IProgressMonitor monitor;

		private MultiStatus buildStatus;

		// this set collects the IIpsSrcFiles that have been build during an
		// incremental build cycle
		// so that this files won't get build mutliple times
		private Set alreadyBuild;

		private IFolder[] outputFolders;

		private IncBuildVisitor(MultiStatus buildStatus,
				IProgressMonitor monitor) throws CoreException {
			this.monitor = monitor;
			this.buildStatus = buildStatus;
			this.alreadyBuild = new HashSet();
			outputFolders = getIpsProject().getOutputFolders();
		}

		/**
		 * Checks if the provided resource is the java output folder resource or
		 * the IpsProject output folder resource.
		 * 
		 * @throws CoreException
		 */
		private boolean ignoredResource(IResource resource)
				throws CoreException {
			IPath outPutLocation = getIpsProject().getJavaProject()
					.getOutputLocation();
			IPath resourceLocation = resource.getFullPath();
			if (outPutLocation.equals(resourceLocation)) {
				return true;
			}
			for (int i = 0; i < outputFolders.length; i++) {
				if (outputFolders[i].getFullPath().equals(resourceLocation)) {
					return true;
				}
			}
			return false;
		}

		public boolean visit(IResourceDelta delta) throws CoreException {
			IResource resource = delta.getResource();
			if (resource == null || resource.getType() == IResource.PROJECT) {
				return true;
			}
			// resources in the output folders of the ipsProject and the
			// assigned java project are
			// ignored
			if (ignoredResource(resource)) {
				return false;
			}
			// TODO check if on classpath and is a source file
			switch (delta.getKind()) {
			case IResourceDelta.ADDED:
				return handleChangedOrAddedResource(resource);
			case IResourceDelta.REMOVED:
				return handleRemovedResource(resource);
			case IResourceDelta.CHANGED: {
				// skip changes, not caused by content changes,
				if (delta.getFlags() != 0) {
					return handleChangedOrAddedResource(resource);
				}
			}
				break;
			}
			return true;
		}

		private boolean handleChangedOrAddedResource(IResource resource)
				throws CoreException {
			IIpsElement element = IpsPlugin.getDefault().getIpsModel()
					.getIpsElement(resource);
			if (element == null || !element.exists()) { // not on classpath?
				return true;
			}
			if (!(element instanceof IIpsSrcFile)) {
				return true;
			}
			IIpsSrcFile file = (IIpsSrcFile) element;
			buildIpsSrcFileIncremental(file, buildStatus, alreadyBuild, monitor);
			return true;
		}

		private boolean handleRemovedResource(IResource resource)
				throws CoreException {
			IIpsElement element = IpsPlugin.getDefault().getIpsModel()
					.getIpsElement(resource);

			if (!(element instanceof IIpsSrcFile)) {
				return true;
			}
			IIpsSrcFile file = (IIpsSrcFile) element;
			IIpsPackageFragmentRoot[] roots = file.getIpsProject()
					.getSourceIpsPackageFragmentRoots();
			for (int i = 0; i < roots.length; i++) {
				if (file.getIpsPackageFragment().getRoot().equals(roots[i])) {
					deleteIpsSrcFile(file, buildStatus, monitor);
					return true;
				}
			}
			return true;
		}
	}

	/**
	 * ResourceDeltaVisitor that counts the resources that have been added,
	 * deleted or changed.
	 */
	private static class WorkLoadVisitor implements IResourceDeltaVisitor {

		int work = 0;

		public boolean visit(IResourceDelta delta) throws CoreException {
			switch (delta.getKind()) {
			case IResourceDelta.ADDED:
				work++;
				break;
			case IResourceDelta.REMOVED:
				work++;
				break;
			case IResourceDelta.CHANGED:
				work++;
				break;
			default:
				throw new RuntimeException(
						"Unkown delta kind " + delta.getKind()); //$NON-NLS-1$
			}
			return true;
		}
	}

	/*
	 * The applyBuildCommand method of this class uses this interface.
	 */
	private interface BuildCommand {
		public void build(IIpsArtefactBuilder builder, MultiStatus status)
				throws CoreException;
	}

	private class BeforeBuildProcessCommand implements BuildCommand {

		private int buildKind;

		public BeforeBuildProcessCommand(int buildKind) {
			this.buildKind = buildKind;
		}

		public void build(IIpsArtefactBuilder builder, MultiStatus status)
				throws CoreException {
			builder.beforeBuildProcess(getIpsProject(), buildKind);
		}

		public String toString() {
			return "BeforeBuildProcessCmd[kind=" + buildKind + "]"; //$NON-NLS-1$ //$NON-NLS-2$
		}

	}

	private class AfterBuildProcessCommand implements BuildCommand {

		private int buildKind;

		public AfterBuildProcessCommand(int buildKind) {
			this.buildKind = buildKind;
		}

		public void build(IIpsArtefactBuilder builder, MultiStatus status)
				throws CoreException {
			builder.afterBuildProcess(getIpsProject(), buildKind);
		}

		public String toString() {
			return "AfterBuildProcessCmd[kind=" + buildKind + "]"; //$NON-NLS-1$ //$NON-NLS-2$
		}
	}

	private static class BuildArtefactBuildCommand implements BuildCommand {

		private IIpsSrcFile ipsSrcFile;

		public BuildArtefactBuildCommand(IIpsSrcFile ipsSrcFile) {
			this.ipsSrcFile = ipsSrcFile;
		}

		public void build(IIpsArtefactBuilder builder, MultiStatus status)
				throws CoreException {
			if (builder.isBuilderFor(ipsSrcFile)) {
				try {
					builder.beforeBuild(ipsSrcFile, status);
					builder.build(ipsSrcFile);
				} finally {
					builder.afterBuild(ipsSrcFile);
				}
			}
		}

		public String toString() {
			return "Build file " + ipsSrcFile; //$NON-NLS-1$
		}
	}

	private static class DeleteArtefactBuildCommand implements BuildCommand {

		private IIpsSrcFile toDelete;

		public DeleteArtefactBuildCommand(IIpsSrcFile toDelete) {
			this.toDelete = toDelete;
		}

		public void build(IIpsArtefactBuilder builder, MultiStatus status)
				throws CoreException {
			if (builder.isBuilderFor(toDelete)) {
				builder.delete(toDelete);
			}
		}

		public String toString() {
			return "Delete file " + toDelete; //$NON-NLS-1$
		}

	}
}
