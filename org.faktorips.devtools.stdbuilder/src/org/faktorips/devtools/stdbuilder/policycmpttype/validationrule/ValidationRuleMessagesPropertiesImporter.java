/*******************************************************************************
 * Copyright (c) Faktor Zehn AG. <http://www.faktorzehn.org>
 * 
 * This source code is available under the terms of the AGPL Affero General Public License version
 * 3.
 * 
 * Please see LICENSE.txt for full license terms, including the additional permissions and
 * restrictions as well as the possibility of alternative license terms.
 *******************************************************************************/

package org.faktorips.devtools.stdbuilder.policycmpttype.validationrule;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;

import org.eclipse.core.resources.IWorkspaceRunnable;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.faktorips.devtools.core.internal.model.pctype.validationrule.ValidationRuleMessagesImportOperation;
import org.faktorips.devtools.core.model.ipsobject.IIpsSrcFile;
import org.faktorips.devtools.core.model.ipsobject.IpsObjectType;
import org.faktorips.devtools.core.model.ipsproject.IIpsPackageFragmentRoot;
import org.faktorips.devtools.core.model.pctype.IPolicyCmptType;
import org.faktorips.devtools.core.model.pctype.IValidationRule;
import org.faktorips.devtools.stdbuilder.StdBuilderPlugin;
import org.faktorips.util.IoUtil;
import org.faktorips.values.LocalizedString;

/**
 * This class implements an algorithm to import a properties file containing the validation messages
 * for {@link IValidationRule}s. The keys have to be in the format as they are generated by
 * {@link ValidationRuleMessagesGenerator}.
 * 
 * @author dirmeier
 */
public class ValidationRuleMessagesPropertiesImporter extends ValidationRuleMessagesImportOperation implements
IWorkspaceRunnable {

    public static final int MSG_CODE_MISSING_MESSAGE = 1;

    public static final int MSG_CODE_ILLEGAL_MESSAGE = 2;

    private Properties properties;

    private IProgressMonitor monitor = new NullProgressMonitor();

    private List<String> importedMessageKeys;

    private MultiStatus missingMessages;

    private MultiStatus illegalMessages;

    public ValidationRuleMessagesPropertiesImporter(InputStream contents, IIpsPackageFragmentRoot root, Locale locale) {
        super(contents, root, locale);
    }

    void setProperties(Properties properties) {
        this.properties = properties;
    }

    @Override
    public void run(IProgressMonitor progressMonitor) throws CoreException {
        if (progressMonitor != null) {
            this.monitor = progressMonitor;
        }
        setResultStatus(importPropertyFile());
    }

    /**
     * This method imports the messages in the give file into the objects found in the specified
     * {@link IIpsPackageFragmentRoot}. The messages are set for the specified locale.
     */
    IStatus importPropertyFile() {
        try {
            loadProperties();
            return importProperties();
        } catch (CoreException e) {
            return e.getStatus();
        } catch (IOException e) {
            return new Status(IStatus.ERROR, StdBuilderPlugin.PLUGIN_ID, "Error while loading property file", e);
        } finally {
            IoUtil.close(getContents());
        }

    }

    void loadProperties() throws IOException {
        setProperties(new Properties());
        properties.load(getContents());
    }

    IStatus importProperties() throws CoreException {
        List<IIpsSrcFile> allPolicyCmptFiled = getPackageFragmentRoot().findAllIpsSrcFiles(
                IpsObjectType.POLICY_CMPT_TYPE);
        try {
            monitor.beginTask("Updating Policy Component Types", allPolicyCmptFiled.size() * 2 + 1);
            initResultFields();
            importValidationMessages(allPolicyCmptFiled);
            checkForIllegalMessages();
            return makeResultStatus();
        } finally {
            monitor.done();
        }
    }

    private void initResultFields() {
        importedMessageKeys = new ArrayList<String>();
        missingMessages = new MultiStatus(StdBuilderPlugin.PLUGIN_ID, MSG_CODE_MISSING_MESSAGE,
                "Missing messages for validation rules", null);
        illegalMessages = new MultiStatus(StdBuilderPlugin.PLUGIN_ID, MSG_CODE_ILLEGAL_MESSAGE,
                "Found illegal messages", null);
    }

    private List<String> importValidationMessages(List<IIpsSrcFile> allIpsSrcFiled) throws CoreException {
        for (IIpsSrcFile ipsSrcFile : allIpsSrcFiled) {
            if (!ipsSrcFile.isMutable()) {
                continue;
            }
            boolean dirtyState = ipsSrcFile.isDirty();
            IPolicyCmptType pcType = (IPolicyCmptType)ipsSrcFile.getIpsObject();
            importValidationMessages(pcType);
            monitor.worked(1);
            if (!dirtyState && ipsSrcFile.isDirty()) {
                ipsSrcFile.save(false, new SubProgressMonitor(monitor, 1));
            }
        }
        return importedMessageKeys;
    }

    private void importValidationMessages(IPolicyCmptType pcType) {
        List<IValidationRule> validationRules = pcType.getValidationRules();
        for (IValidationRule validationRule : validationRules) {
            String messageKey = validationRule.getQualifiedRuleName();
            String message = properties.getProperty(messageKey);
            if (updateValidationMessage(validationRule, message)) {
                importedMessageKeys.add(messageKey);
            } else {
                missingMessages.add(new Status(IStatus.WARNING, StdBuilderPlugin.PLUGIN_ID,
                        "Did not found a message for Rule " + validationRule.getName() + " in Policy Component Type"
                                + pcType.getQualifiedName() + ". Message key is: " + messageKey));
            }
        }
    }

    private boolean updateValidationMessage(IValidationRule validationRule, String message) {
        if (message == null) {
            return false;
        } else {
            validationRule.getMessageText().add(new LocalizedString(getLocale(), message));
            return true;
        }
    }

    private void checkForIllegalMessages() {
        if (importedMessageKeys.size() < properties.size()) {
            for (Object key : properties.keySet()) {
                if (!importedMessageKeys.contains(key)) {
                    illegalMessages.add(new Status(IStatus.WARNING, StdBuilderPlugin.PLUGIN_ID, "Messagekey " + key
                            + " is not valid. No rule was found for the specified name."));
                }
            }
        }
        monitor.worked(1);
    }

    private IStatus makeResultStatus() {
        MultiStatus result = new MultiStatus(StdBuilderPlugin.PLUGIN_ID, 0, "Problems during importing messages", null);
        if (!illegalMessages.isOK()) {
            result.add(illegalMessages);
        }
        if (!missingMessages.isOK()) {
            result.add(missingMessages);
        }
        if (result.isOK()) {
            return new Status(IStatus.OK, StdBuilderPlugin.PLUGIN_ID, "");
        } else {
            return result;
        }
    }
}
