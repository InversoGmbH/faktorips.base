«IMPORT org::faktorips::devtools::stdbuilder»
«IMPORT org::faktorips::devtools::core::builder::naming»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::template»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::MethodNames»
«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::CommonGeneratorExtensions»

«DEFINE main FOR XPolicyCmptClass»
	«FILE getFileName(BuilderAspect::IMPLEMENTATION)-»
package «packageName»;

«EXPAND CommonDefinitions::ImportBlock FOREACH context.imports ONFILECLOSE»
	
	/**
	 «IF generatingPublishedInterfaces-»
	 *	«localizedJDoc("CLASS", getSimpleName(BuilderAspect::INTERFACE))»
	 «ENDIF-»
	 * @generated
	 */
	 «getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS)-»
	public «abstract()» class «className» extends «superclassName-» «EXPAND CommonDefinitions::implementedInterfaces»{

		«FOREACH attributes AS this-»
			«IF !published-»
				«EXPAND PolicyCmptAttribute::constantForPropertyName-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«FOREACH attributes AS this-»
			«IF constant-»
				«EXPAND PolicyCmptAttribute::memberField-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«EXPAND PropertyChangeSupport::fieldDefinition-»

		«FOREACH attributes AS this-»
			«IF !constant-»
				«EXPAND PolicyCmptAttribute::memberField-»
			«ENDIF-»
		«ENDFOREACH-»
		
		«FOREACH associations AS this-»
			«EXPAND PolicyCmptAssociation::field-»
		«ENDFOREACH-»
		
		«FOREACH inverseCompositions AS this-»
			«EXPAND PolicyCmptAssociation::fieldForParent-»
		«ENDFOREACH-»
			
		«EXPAND constructors-»
		
		«FOREACH attributes AS this-»
			«EXPAND PolicyCmptAttribute::allowedValuesMethod-»
			«EXPAND PolicyCmptAttribute::getter-»
			«EXPAND PolicyCmptAttribute::setter-»
		«ENDFOREACH-»

		«EXPAND DerivedUnionAssociation::methodDerivedUnionContains(this) FOREACH  derivedUnionAssociations»

		«FOREACH associations AS this-»
			«EXPAND PolicyCmptAssociation::methods-»
		«ENDFOREACH-»
		
		«EXPAND DerivedUnionAssociation::methodsForDerivedUnionPolicy(this) FOREACH  derivedUnionAssociations»

		«EXPAND generalMethodsForConfiguredPolicyCmpts-»
	    
	 	«EXPAND generateCodeForDependentObject»
	   
		«EXPAND PropertyChangeSupport::generalMethods-»
		
		«EXPAND generalMethods-»

		}
	«ENDFILE»
«ENDDEFINE»

«DEFINE constructors FOR XPolicyCmptClass-»
	/**
     * «localizedJDoc("CONSTRUCTOR", className)»
     * 
     * @generated
     */
    public «className»() {
        super();
        «EXPAND initializationForOverrideAttributes-»
    }
    «IF configured»
	/**
     * «localizedJDoc("CONSTRUCTOR", className)»
     * 
     * @generated
     */
    public «className»(«productComponentClassOrInterfaceName» productCmpt) {
        super(productCmpt);
        «EXPAND initializationForOverrideAttributes-»
    }
    «ENDIF»
«ENDDEFINE»


«DEFINE initializationForOverrideAttributes FOR XPolicyCmptClass-»
	«FOREACH attributes AS this-»
		«IF generateDefaultInitialize-»
			«methodNameSetter»(«defaultValueCode»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE generalMethodsForConfiguredPolicyCmpts FOR XPolicyCmptClass-»
	«IF configured-»
	    /**
	     * «localizedJDoc("METHOD_INITIALIZE")»
	     * 
	     * @restrainedmodifiable
	     */
		 «overrideAnnotation(false)»
	    public void «initialize()» {
	    	«IF hasSupertype()-»
		        super.«initialize()»;
	        «ENDIF-»
	    	«IF !attributesToInitWithProductData.isEmpty-»
		        if («methodNameGetProductCmptGeneration»() == null) {
		            return;
		        }
		        «FOREACH attributesToInitWithProductData AS this-»
					«EXPAND PolicyCmptAttribute::initConfigurableAttribute-»
		        «ENDFOREACH-»
	        «ENDIF-»
		    // begin-user-code
		    // end-user-code
	    }
		 
		/**
		 * {@inheritDoc}
		 *
		 * @generated
		 */
		 «overrideAnnotation(false)»
		 public «productComponentClassOrInterfaceName» «methodNameGetProductComponent»() {
		 	return («productComponentClassOrInterfaceName») «getProductComponent()»;
		 }
		 
		/**
		 * {@inheritDoc}
		 *
		 * @generated
		 */
		 «overrideAnnotation(false)»
		 public «productGenerationClassOrInterfaceName» «methodNameGetProductCmptGeneration»() {
		 	return («productGenerationClassOrInterfaceName») «getProductCmptGeneration()»;
		 }
	
		/**
		 * {@inheritDoc}
		 *
		 * @generated
		 */
		 «overrideAnnotation(false)»
		 public void «methodNameSetProductComponent»(«productComponentClassOrInterfaceName» «productComponentArgumentName», boolean initPropertiesWithConfiguratedDefaults) {
	        «setProductComponent(productComponentArgumentName)»;
	        if (initPropertiesWithConfiguratedDefaults) {
	            «initialize()»;
	        }
		 }
		 /**
		 * {@inheritDoc}
		 *
	     * @generated
	     */
		 «overrideAnnotation(false)»
	    public void «effectiveFromHasChanged()» {
	        super.«effectiveFromHasChanged()»;
	        «EXPAND PolicyCmptAssociation::delegateEffectiveFromHasChanged FOREACH associations-»
	    }
	    
		/**
		 * {@inheritDoc}
		 *
		 * @generated
		 */
		 «overrideAnnotation(false)»
		 public «Calendar()» «getEffectiveFromAsCalendar()» {
		 	«IF aggregateRoot-»
			 	«IF hasSupertype()-»
			 		return super.«getEffectiveFromAsCalendar()»;
			 	«ELSE-»
			 	    return null;
			 	    «localizedComment("METHOD_GET_EFFECTIVE_FROM_TODO_LINE1")»
			 	    «localizedComment("METHOD_GET_EFFECTIVE_FROM_TODO_LINE2")»
			 	    «localizedComment("METHOD_GET_EFFECTIVE_FROM_TODO_LINE3")»
			 	«ENDIF-»
			 «ELSE-»
			        «IModelObject()» parent = «getParentModelObject()»;
			        if (parent instanceof «IConfigurableModelObject()») {
			            return ((«IConfigurableModelObject()»)parent).«getEffectiveFromAsCalendar()»;
			        }
			        return null;
			 «ENDIF-»
		 }
	 «ENDIF-»
«ENDDEFINE»

«DEFINE generateCodeForDependentObject FOR XPolicyCmptClass-»«REM»
	 if (isFirstDependantTypeInHierarchy(getPcType()) && getPcType().isConfigurableByProductCmptType()) {
            generateMethodGetEffectiveFromAsCalendarForDependantObjectBaseClass(methodBuilder);
        }

        // generate Method getParentModelObject()
        generateMethodGetParentModelObject(methodBuilder, detailToMasterAssociations);

        // methods create for each parent
        for (IPolicyCmptTypeAssociation association : detailToMasterAssociations) {
            generateFieldForParent(memberVarsBuilder, association);
            generateMethodSetParentObjectInternal(methodBuilder, association);
        }

        // methods for subset of derived union associations
        // we must first collect a map of all inverse-of-derived-union-association-generators
        // containing a list of the corresponding subset-derived-union-associations
        // because a subset of a derived union could be added in the same class multiple times
        // but we need to create the getter for the parent object only once
        Map<GenAssociation, List<IPolicyCmptTypeAssociation>> inverseOfDerivedUnionAssociationGenerators = getAllInverseOfDerivedUnionAssociationsGenerator(getPcType());
        for (Map.Entry<GenAssociation, List<IPolicyCmptTypeAssociation>> entry : inverseOfDerivedUnionAssociationGenerators
                .entrySet()) {
            generateMethodGetterForInverseOfDerivedUnion(methodBuilder, entry.getKey(), entry.getValue());
        }«ENDREM»

	«IF generateGetParentModelObject-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		 «overrideAnnotation(false)»
	    public «IModelObject()» «getParentModelObject()» {
	    	«FOREACH inverseCompositions AS this-»
		        if («fieldName» != null) {
		            return «fieldName»;
		        }
	    	«ENDFOREACH-»
	        return null;
	    }
    «ENDIF-»
	
	«FOREACH inverseCompositions AS this-»
		«EXPAND PolicyCmptAssociation::methodSetParentInternal-»
	«ENDFOREACH-»
	
«ENDDEFINE»

«DEFINE generalMethods FOR XPolicyCmptClass-»
	«IF generateInitPropertiesFromXML-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		 «overrideAnnotation(false)»
	    protected void «initPropertiesFromXml(Map("String", "String")+" propMap", IRuntimeRepository()+" productRepository")» {
	        super.«initPropertiesFromXml("propMap", "productRepository")»;
			«EXPAND PolicyCmptAttribute::initAttributeFromXML FOREACH attributes-»
	    }
    «ENDIF-»
    
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    «overrideAnnotation(false)»
    protected «AbstractModelObject()» «createChildFromXml(Element()+" childEl")» {
        «AbstractModelObject()» newChild = super.«createChildFromXml("childEl")»;
        if (newChild != null) {
            return newChild;
        }
        «EXPAND PolicyCmptAssociation::createTargetFromXML FOREACH associations-»
        return null;
    }
    
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    «overrideAnnotation(false)»
    protected «IUnresolvedReference()» «createUnresolvedReference("Object objectId, String targetRole, String targetId")»
            throws Exception {
        «EXPAND PolicyCmptAssociation::createUnresolvedReference FOREACH associations-»
        return super.createUnresolvedReference(objectId, targetRole, targetId);
    }

	«IF generateDeltaSupport-»
    	«EXPAND DeltaSupport::computeDeltaMethod-»
    «ENDIF-»

    «IF generateCopySupport-»
    	«EXPAND CopySupport::copyMethods-»
    «ENDIF-»
    
    «IF generateVisitorSupport-»
    	«EXPAND VisitorSupport::acceptMethod-»
    «ENDIF-»
    
    «EXPAND validateMethods-»
«ENDDEFINE»

«DEFINE validateMethods FOR XPolicyCmptClass-»
    /**
     * «localizedJDoc("VALIDATE_SELF")»
     * 
     * @generated
     */
    «overrideAnnotation(true)»
    public boolean «validateSelf(MessageList()+" ml", IValidationContext()+" context")» {
        if (!super.«validateSelf("ml", "context")») {
            return STOP_VALIDATION;
        }
        return CONTINUE_VALIDATION;
    }

    /**
     * «localizedJDoc("VALIDATE_DEPENDANTS")»
     * 
     * @generated
     */
    «overrideAnnotation(true)»
    public void «validateDependants(MessageList()+" ml", IValidationContext()+" context")» {
        super.«validateDependants("ml", "context")»;
        «EXPAND PolicyCmptAssociation::validateDependents FOREACH associations-»
        «FOREACH derivedUnionAssociations AS assoc-»
        	«IF !assoc.isImplementedInSuperclass(this)-»
        		«EXPAND PolicyCmptAssociation::validateDependents FOR assoc»
        	«ENDIF-»
        «ENDFOREACH-»
    }
«ENDDEFINE»
