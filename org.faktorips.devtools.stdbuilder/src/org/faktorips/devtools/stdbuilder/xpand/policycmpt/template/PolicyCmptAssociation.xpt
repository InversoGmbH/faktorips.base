«IMPORT org::faktorips::devtools::stdbuilder»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::runtime»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::productcmpt::template»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::policycmpt::template::PolicyCmptAssociationExtension»
«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::ClassNames»

«DEFINE field FOR XPolicyAssociation-»
	«IF generateField-»
	    /**
	     * «localizedJDoc("FIELD_ASSOCIATION", name)»
	     * 
	     * @generated
	     */
		«IF oneToMany-»
			«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_ASSOCIATION)-»
			private «List_(targetInterfaceName)» «field(fieldName)»  = new «ArrayList(targetInterfaceName)»();
		«ELSE-»
			«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_ASSOCIATION)-»
			private «targetClassName» «field(fieldName)» = null;
		«ENDIF»
	«ENDIF-»
«ENDDEFINE»

«DEFINE methods FOR XPolicyAssociation-»
	«EXPAND ProductAssociation::getNumOf-»
	«EXPAND contains-»
	«EXPAND getters-»
	«EXPAND setterMethodsForToOne-»
	«EXPAND newChildMethods-»
	«EXPAND add-»
	«EXPAND remove-»
«ENDDEFINE»

«DEFINE contains FOR XAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
     	«overrideAnnotationForPublishedMethod()-»
	    public boolean «method(methodNameContains, targetInterfaceName, "objectToTest")» {
	    	«IF derivedUnion-»	    		
		        return «methodNameGetter»().contains(objectToTest);
	    	«ELSE-»
		        return «fieldName».contains(objectToTest);
	    	«ENDIF-»
	    }
    «ENDIF»
«ENDDEFINE»

«DEFINE getters FOR XPolicyAssociation-»
	«IF generateGetter»
		«IF oneToMany-»
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
		    «overrideAnnotation(true)-»
		    public «List_(targetInterfaceName)» «method(methodNameGetter)» {
		        return «Collections()».unmodifiableList(«fieldName»);
		    }
		
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
		    «overrideAnnotation(true)-»
		    public «targetInterfaceName» «method(methodNameGetSingle, "int", "index")» {
		        return «fieldName».get(index);
		    }
	    «ELSE-»
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
		    «overrideAnnotation(true)-»
		    public «targetInterfaceName» «method(methodNameGetSingle)» {
		        return «fieldName»;
		    }
	    «ENDIF-»
    «ENDIF»
«ENDDEFINE»

«DEFINE setterMethodsForToOne FOR XPolicyAssociation-»
	«IF !oneToMany && !inverseComposition-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)-»
	    public void «method(methodNameSetter, targetInterfaceName, "newObject")» {
	    	«IF generateChangeSupport-»
				«EXPAND PropertyChangeSupport::storeOldValue-»
		        «methodNameSetInternal»(newObject);
				«EXPAND PropertyChangeSupport::notify-»
			«ELSE-»
				«EXPAND setterMethodCode-»
			«ENDIF-»
	    }

    	«IF generateChangeSupport-»
		    /** «REM»TODO old codegenerator writes the comment only for compositions«ENDREM»
		     «IF !typeAssociation-» 
		     * «localizedJDoc("METHOD_SET_OBJECT_INTERNAL", name.toFirstUpper())»
		     * 
		     «ENDIF-»
		     * @generated
		     */
		    public void «method(methodNameSetInternal, targetInterfaceName, "newObject")»{
				«EXPAND setterMethodCode-»
	    	}	
		«ENDIF-»
    «ENDIF-»
«ENDDEFINE»
«DEFINE setterMethodCode FOR XPolicyAssociation-»
	«IF compositionMasterToDetail-»
        if («fieldName» != null) {
            «EXPAND synchronizeInverseCompositionIfNecessaryForSet(false, fieldName, "null")-»
        }
        if (newObject != null) {
            «EXPAND synchronizeInverseCompositionIfNecessaryForSet(true, "newObject", "this")-»
        }
        «fieldName» = «EXPAND castToImplementationIfNecessary» newObject;
    	«EXPAND synchronizeInverseAssociationIfNecessary(fieldName)-»
    «ENDIF-»
    «IF typeAssociation-»
    	if (newObject == «fieldName») return;
    	«IF hasInverseAssociation()-»
	        «targetInterfaceName» oldRefObject = «fieldName»;
	        «fieldName» = null;
	        «EXPAND cleanupOldReference("oldRefObject")-»
	    «ENDIF-»
        «fieldName» = «EXPAND castToImplementationIfNecessary» newObject;
    	«EXPAND synchronizeInverseAssociationIfNecessary(fieldName)-»
    «ENDIF-»
«ENDDEFINE»
«DEFINE synchronizeInverseCompositionIfNecessaryForSet(boolean cast, String varName, String newRef) FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForSet-»
		«IF cast»«EXPAND castIfNeccessary(varName)»«ELSE»«varName»«ENDIF».«methodNameInverseAssociationSetInternal»(«newRef»);
    «ENDIF-»
«ENDDEFINE»

«DEFINE cleanupOldReference(String varToCleanUp) FOR XPolicyAssociation-»
	«IF !oneToMany-»
		if(«varToCleanUp» != null){
        	«EXPAND cleanupOldReferenceInner(varToCleanUp)-»
		}
    «ELSE-»
    	«EXPAND cleanupOldReferenceInner(varToCleanUp)-»
    «ENDIF-»
«ENDDEFINE»
«DEFINE cleanupOldReferenceInner(String varToCleanUp) FOR XPolicyAssociation-»
	«IF inverseAssociation.oneToMany»
		«varToCleanUp».«methodNameInverseAssociationRemove»(this);
    «ELSE-»
		«varToCleanUp».«methodNameInverseAssociationSet»(null);    	
    «ENDIF-»
«ENDDEFINE»

«DEFINE castIfNeccessary(String varName) FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»
	(«EXPAND castToImplementationIfNecessary»«varName»)«ELSE-»
	«varName»«ENDIF-»
«ENDDEFINE»

«DEFINE castToImplementationIfNecessary FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»(«targetClassName»)«ENDIF-»
«ENDDEFINE»

«DEFINE newChildMethods FOR XPolicyAssociation-»
	«IF generateNewChildMethods-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameNew)»{
	        «targetClassName» «variableNameNewInstance» = new «targetClassName»();
			«EXPAND addOrSetNewInstance-»
	        «variableNameNewInstance».«initialize()»;
	        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
	        return «variableNameNewInstance»;
	    }
	
		«IF generateNewChildWithArgumentsMethod-»
		    /**
		     * {@inheritDoc}
		     * 
		     * @generated
		     */
			«overrideAnnotation(true)»
		    public «targetInterfaceName» «method(methodNameNew, targetProductCmptInterfaceName, targetProductCmptVariableName)» {
		        if («targetProductCmptVariableName» == null) {
		            return «methodNameNew»();
		        }
		        «targetInterfaceName» «variableNameNewInstance» = «targetProductCmptVariableName».«methodNameCreatePolicyCmptForTargetProductCmpt»(); 
				«EXPAND addOrSetNewInstance-»
		        «variableNameNewInstance».«initialize()»;
		        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
		        return «variableNameNewInstance»;
		    }
	    «ENDIF-»
    «ENDIF-»
«ENDDEFINE»

«DEFINE addOrSetNewInstance FOR XPolicyAssociation-»
	«IF oneToMany-»
       	«methodNameAddInternal»(«variableNameNewInstance»);
    «ELSE-»
       	«methodNameSetInternal»(«variableNameNewInstance»);
    «ENDIF-»
«ENDDEFINE»

«DEFINE add FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameAdd, targetInterfaceName, "objectToAdd")»{
	        «methodNameAddInternal»(objectToAdd);
	        «EXPAND PropertyChangeSupport::notifyNewAssociation("objectToAdd")-»
	    }
	
	    /**
	     * «localizedJDoc("METHOD_ADD_OBJECT_INTERNAL", name)»
	     * 
	     * @generated
	     */
	    public void «method(methodNameAddInternal, targetInterfaceName, "objectToAdd")»{
	        if (objectToAdd == null) {
	            throw new NullPointerException("Can't add null to association «name» of " + this);
	        }
	        if («fieldName».contains(objectToAdd)) {
	            return;
	        }
	        «EXPAND synchronizeInverseCompositionIfNecessaryForAdd-»
			«fieldName».add(objectToAdd);
	        «EXPAND synchronizeInverseAssociationIfNecessary("objectToAdd")-»
	    }
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseCompositionIfNecessaryForAdd FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForAdd-»
		«EXPAND castIfNeccessary("objectToAdd")».«methodNameInverseAssociationSetInternal»(this);
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseAssociationIfNecessary(String objectToSynchronize) FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseAssociation-»
		«IF oneToMany-»
			if («EXPAND varNameNullCheckIfNecessary(objectToSynchronize)» !«objectToSynchronize».«methodNameInverseAssociationContains»(this)) {
				«objectToSynchronize».«methodNameInverseAssociationAdd»(this);
			}
	    «ELSE-»
	    	if («EXPAND varNameNullCheckIfNecessary(objectToSynchronize)» «objectToSynchronize».«methodNameInverseAssociationGet»()!=this) {
				«objectToSynchronize».«methodNameInverseAssociationSet»(this);
				«IF false-»
				«REM» Der alte Codegenerator baut hier evtl. einen Cast ein:
			        if (!varClassName.equals(getGenType().getQualifiedName(false))) {
			            code.append("((");
			            code.appendClassName(getGenType().getQualifiedName(false));
			            code.append(")" + varName + ").");
			        }
			        Wird das fuer Derived Union auch mal verwendet, oder ist das ueberfluessig?
				«ENDREM»
				«ENDIF-»
			}
	    «ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE varNameNullCheckIfNecessary(String varName) FOR XPolicyAssociation-»
	«IF !inverseAssociation.oneToMany-»
		«varName» !=null &&
	«ENDIF-»
«ENDDEFINE»

«DEFINE remove FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameRemove, targetInterfaceName, "objectToRemove")»{
	        if (objectToRemove == null) {
	            return;
	        }
			«EXPAND removeAndDetach-»
	        «EXPAND PropertyChangeSupport::notifyRemovedAssociation("objectToRemove")-»
	    }
    «ENDIF-»
«ENDDEFINE»

«REM»
	Test nötig: Composition ohne inverse Relation
		-> alter Generator sollte leeres if(){} aber kein detach generieren
«ENDREM»
«DEFINE removeAndDetach FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForRemove-»
		if («fieldName».remove(objectToRemove)) {
			«EXPAND detachRemovedObject-»
		}
	«ELSE-»
		«fieldName».remove(objectToRemove);
	«ENDIF-»
«ENDDEFINE»

«DEFINE detachRemovedObject FOR XPolicyAssociation-»
	«IF hasInverseAssociation()-»
		«IF inverseAssociation.oneToMany-»
			objectToRemove.«methodNameInverseAssociationRemove»(this);
		«ELSE-»
			«EXPAND castIfNeccessary("objectToRemove")».«methodNameInverseAssociationSetInternal»(null);
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE delegateEffectiveFromHasChanged FOR XPolicyAssociation-»
	«IF considerInEffectiveFromHasChanged-»
		«IF oneToMany-»
			for («Iterator(targetInterfaceName)» it = «fieldName».iterator(); it.hasNext();) {
	            «AbstractConfigurableModelObject()» child = («AbstractConfigurableModelObject()»)it.next();
	            child.effectiveFromHasChanged();
	        }
		«ELSE-»
			if («fieldName» != null) {
	            ((«AbstractConfigurableModelObject()»)«fieldName»).effectiveFromHasChanged();
	        }
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE validateDependents FOR XAssociation-»
	«IF considerInValidateDependents-»
        «IF oneToMany-»
	        if («methodNameGetNumOf»() > 0) {
	            for («targetInterfaceName» rel : «methodNameGetter»()) {
	                ml.add(rel.validate(context));
	            }
	        }
        «ELSE-»
        	if («fieldName» != null) {
	            ml.add(«fieldName».validate(context));
	        }
        «ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE createTargetFromXML FOR XPolicyAssociation-»
	«IF considerInCreateChildFromXML-»
        if ("«name»".equals(childEl.getNodeName())) {
            String className = childEl.getAttribute("class");
            if (className.length() > 0) {
                try {
                    «targetClassName» «createChildFromXMLLocalVarName» = («targetClassName»)Class.forName(className).newInstance();
                    «IF oneToMany-»
	                    «methodNameAdd»(«createChildFromXMLLocalVarName»);
                    «ELSE-»
	                    «methodNameSetter»(«createChildFromXMLLocalVarName»);                    	
                    «ENDIF-»
                    return «createChildFromXMLLocalVarName»;
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            «IF abstractTarget-»
            	throw new RuntimeException(childEl.toString() + ": Attribute className is missing.");
            «ELSE-»
            	return («AbstractModelObject()»)«methodNameNew»();
            «ENDIF-»
        }
	«ENDIF-»
«ENDDEFINE»

«DEFINE createUnresolvedReference FOR XPolicyAssociation-»
	«IF considerInCreateCreateUnresolvedReference-»
		if ("«name»".equals(targetRole)) {
            return new «DefaultUnresolvedReference()»(this, objectId, "«IF oneToMany»«methodNameAdd»«ELSE»«methodNameSetter»«ENDIF-»",
                    «targetInterfaceName».class, targetId);
        }
	«ENDIF-»
«ENDDEFINE»

«REM» Templates for detailToMaster compositions«ENDREM»
«DEFINE fieldForParent FOR XPolicyAssociation-»
	/**
	 * «localizedJDoc("FIELD_PARENT", targetClassName)»
	 *
	 * @generated	 
	 */
	«getAnnotations(AnnotatedJavaElementType::POLICY_CMPT_IMPL_CLASS_ASSOCIATION)-»
	private «targetClassName» «field(fieldName)»;
«ENDDEFINE»
«DEFINE methodSetParentInternal FOR XPolicyAssociation-»
	/**
     * @generated
     */
    public void «methodNameSetInternal»(«targetInterfaceName» newParent) {
        if («methodNameGetSingle»() == newParent) {«REM»parent association can only be 1to1. getSingle can be used.«ENDREM»
            return;
        }
        «IModelObject()» «parentVar()» = «getParentModelObject()»;
        if (newParent != null && «parentVar()» != null) {
            throw new RuntimeException(
                    "«className» can't be assigned to parent object of class «name», because object already belongs to a different parent object.");
        }
        this.«fieldName» = «EXPAND castToImplementationIfNecessary» newParent;
        «IF typeConfigurableByProductCmptType-»
        	effectiveFromHasChanged();
		«ENDIF-»
    }
«ENDDEFINE»

        