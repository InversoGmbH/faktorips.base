«IMPORT java::util»
«IMPORT org::faktorips::devtools::core::builder::naming»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::template»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::productcmpt::model»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::policycmpt::template::PolicyCmptExtension»

«DEFINE field FOR XProductAssociation»
	«IF !derived»
	    /**
	     * «localizedJDoc("FIELD_ASSOCIATION", getName(onetoMany))»
	     * 
	     * @generated
	     */
		«IF onetoMany»
			private «Map()»<String, «IProductComponentLink()»<«targetClassName»>> «memberVarName»  = new «LinkedHashMap()»<String, «IProductComponentLink()»<«targetClassName»>>(0);
		«ELSE»
			private «IProductComponentLink()»<«targetClassName»> «name.toFirstLower()» = null;
		«ENDIF»
	«ENDIF»
	
«ENDDEFINE»

«DEFINE getterSetterAdder FOR XProductAssociation-»
	«IF !derived»
		«EXPAND getterProductCmpt»
		«EXPAND getterProductCmptGen»
		«EXPAND getterProductCmptPerIndex»
    «ENDIF»
«ENDDEFINE»

«DEFINE getterProductCmpt FOR XProductAssociation-»
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
     «overrideAnnotation(true)»
   	«IF onetoMany-»
	    public «List_()»<«targetClassName»> «getterMethodName»() {
        	«List_()»<«targetClassName»> result = new «ArrayList()»<«targetClassName»>(«memberVarName».size());
			for («IProductComponentLink()»<«targetClassName»> «name.toFirstLower()» : «memberVarName».values()) {
	            result.add(«name.toFirstLower()».«getTarget()»);
    	    }
        	return result;
    «ELSE-»
	    public «targetClassName» «getterMethodName»() {
			return «memberVarName» != null ? «memberVarName».«getTarget()» : null;
    «ENDIF-»
    }
«ENDDEFINE»

«DEFINE getterProductCmptGen FOR XProductAssociation-»
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
     «overrideAnnotation(true)»
   	«IF onetoMany-»
	    public «List_()»<«targetClassGenerationName»> «getterMethodName»(«Calendar()» effectiveDate) {
        	«List_()»<«targetClassName»> targets = «getterMethodName»();
        	«List_()»<«targetClassGenerationName»> result = new «ArrayList()»<«targetClassGenerationName»>();
			for («targetClassName» target : targets) {
				«targetClassGenerationName» gen = target.«getterNameForTargetGeneration»(effectiveDate);
				if (gen != null) {
	                result.add(gen);
            }
        }
        return result;
    «ELSE-»
	    public «targetClassGenerationName» «getterMethodName»(«Calendar()» effectiveDate) {
			return «memberVarName» != null ? «memberVarName».«getTarget()».«getterNameForTargetGeneration»(effectiveDate) : null;
    «ENDIF-»
    }
«ENDDEFINE»

«DEFINE getterProductCmptPerIndex FOR XProductAssociation-»
	«IF onetoMany-»
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
     «overrideAnnotation(true)»
	public «targetClassName» «getGetterMethodName(false)»(int index) {
		«Iterator()»<«IProductComponentLink()»<«targetClassName»>> it = «memberVarName».values().iterator();
        try {
            for (int i = 0; i < index; i++) {
                it.next();
            }
            return it.next().«getTarget()»;
        } catch («NoSuchElementException()» e) {
            throw new IndexOutOfBoundsException(e.getLocalizedMessage());
        }
		
	}
	«ENDIF»
«ENDDEFINE»

«REM»
    @Override
    public IDeckungsTyp getDeckungsTyp(int index) {
        Iterator<IProductComponentLink<IDeckungsTyp>> it = deckungsTypen.values().iterator();
        try {
            for (int i = 0; i < index; i++) {
                it.next();
            }
            return it.next().getTarget();
        } catch (NoSuchElementException e) {
            throw new IndexOutOfBoundsException(e.getLocalizedMessage());
        }
    }

    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    @Override
    public Collection<IProductComponentLink<IDeckungsTyp>> getLinksForDeckungsTypen() {
        return Collections.unmodifiableCollection(deckungsTypen.values());
    }

    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    @Override
    public IProductComponentLink<IDeckungsTyp> getLinkForDeckungsTyp(IDeckungsTyp productComponent) {
        return deckungsTypen.get(productComponent.getId());
    }

    /**
     * Adds the given product component.
     * 
     * @generated
     */
    public void addDeckungsTyp(IDeckungsTyp target) {
        if (getRepository() != null && !getRepository().isModifiable()) {
            throw new IllegalRepositoryModificationException();
        }
        this.deckungsTypen.put(target.getId(), new ProductComponentLink<IDeckungsTyp>(this, target));
    }

    /**
     * Adds the given product component with the given cardinality.
     * 
     * @generated
     */
    public void addDeckungsTyp(IDeckungsTyp target, CardinalityRange cardinality) {
        if (getRepository() != null && !getRepository().isModifiable()) {
            throw new IllegalRepositoryModificationException();
        }
        this.deckungsTypen.put(target.getId(), new ProductComponentLink<IDeckungsTyp>(this, target, cardinality));
    }

    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    @Override
    public CardinalityRange getCardinalityForDeckung(IDeckungsTyp productCmpt) {
        if (productCmpt != null) {
            return deckungsTypen.containsKey(productCmpt.getId()) ? deckungsTypen.get(productCmpt.getId())
                    .getCardinality() : null;
        }
        return null;
    }

    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    @Override
    public int getNumOfDeckungsTypen() {
        return deckungsTypen.size();
    }
«ENDREM»


«DEFINE setter FOR XProductAssociation»
«ENDDEFINE»
