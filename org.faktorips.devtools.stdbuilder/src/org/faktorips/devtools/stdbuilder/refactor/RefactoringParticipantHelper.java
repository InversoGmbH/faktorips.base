/*******************************************************************************
 * Copyright (c) 2005-2011 Faktor Zehn AG und andere.
 * 
 * Alle Rechte vorbehalten.
 * 
 * Dieses Programm und alle mitgelieferten Sachen (Dokumentationen, Beispiele, Konfigurationen,
 * etc.) duerfen nur unter den Bedingungen der Faktor-Zehn-Community Lizenzvereinbarung - Version
 * 0.1 (vor Gruendung Community) genutzt werden, die Bestandteil der Auslieferung ist und auch unter
 * http://www.faktorzehn.org/fips:lizenz eingesehen werden kann.
 * 
 * Mitwirkende: Faktor Zehn AG - initial API and implementation - http://www.faktorzehn.de
 *******************************************************************************/

package org.faktorips.devtools.stdbuilder.refactor;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.resources.IWorkspaceRunnable;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.ltk.core.refactoring.Change;
import org.eclipse.ltk.core.refactoring.CheckConditionsOperation;
import org.eclipse.ltk.core.refactoring.NullChange;
import org.eclipse.ltk.core.refactoring.PerformRefactoringOperation;
import org.eclipse.ltk.core.refactoring.Refactoring;
import org.eclipse.ltk.core.refactoring.RefactoringStatus;
import org.eclipse.ltk.core.refactoring.RefactoringStatusEntry;
import org.eclipse.ltk.core.refactoring.participants.CheckConditionsContext;
import org.eclipse.ltk.core.refactoring.participants.RefactoringParticipant;
import org.eclipse.ltk.core.refactoring.resource.DeleteResourceChange;
import org.eclipse.swt.widgets.Display;
import org.faktorips.devtools.core.IpsPlugin;
import org.faktorips.devtools.core.model.IIpsElement;
import org.faktorips.devtools.core.model.ipsobject.IIpsObject;
import org.faktorips.devtools.core.model.ipsobject.IIpsObjectPartContainer;
import org.faktorips.devtools.core.model.ipsobject.IIpsSrcFile;
import org.faktorips.devtools.core.model.ipsproject.IIpsArtefactBuilderSet;
import org.faktorips.devtools.core.model.ipsproject.IIpsPackageFragment;
import org.faktorips.devtools.core.model.ipsproject.IIpsProject;
import org.faktorips.devtools.core.util.RefactorUtil;
import org.faktorips.devtools.stdbuilder.StandardBuilderSet;
import org.faktorips.util.ArgumentCheck;

/**
 * Because all refactoring participants must be derived from an abstract LTK base class we can't use
 * inheritance ourselves to provide common functionality for the standard builder refactoring
 * participants.
 * <p>
 * Instead of using inheritance every participant may hold a {@link RefactoringParticipantHelper}.
 * <p>
 * A {@link RefactoringParticipantHelper} is able to refactor the Java source code in terms of the
 * Faktor-IPS refactoring by successively calling JDT refactorings on the {@link IJavaElement}
 * generated by the code generator for the {@link IIpsObjectPartContainer} to be refactored.
 * 
 * @author Alexander Weickmann
 */
public abstract class RefactoringParticipantHelper {

    /**
     * List containing the {@link IJavaElement}s generated originally for the
     * {@link IIpsObjectPartContainer} to be refactored.
     */
    private List<IJavaElement> originalJavaElements;

    /**
     * List containing the {@link IJavaElement}s generated for the {@link IIpsObjectPartContainer}
     * to be refactored as they will be after the refactoring. This information is needed to be able
     * to provide the JDT refactorings with the correct new names for the {@link IJavaElement}s.
     */
    private List<IJavaElement> targetJavaElements;

    private IIpsProject ipsProject;

    /**
     * Checks the conditions of the JDT refactorings to be performed.
     * 
     * @see RefactoringParticipant#checkConditions(IProgressMonitor, CheckConditionsContext)
     */
    public final RefactoringStatus checkConditions(IProgressMonitor pm) throws OperationCanceledException {
        RefactoringStatus status = new RefactoringStatus();

        for (int i = 0; i < getNumberOfJavaElementsToRefactor(); i++) {
            IJavaElement originalJavaElement = originalJavaElements.get(i);

            /*
             * The refactoring may be executed without present Java code or the Java element might
             * already have been refactored as a side-effect of the refactoring of a previous
             * element.
             */
            if (!(originalJavaElement.exists())) {
                continue;
            }

            // Ignore constructors as they will not be refactored
            if (originalJavaElement instanceof IMethod) {
                try {
                    if (((IMethod)originalJavaElement).isConstructor()) {
                        continue;
                    }
                } catch (JavaModelException e) {
                    RefactoringStatus errorStatus = new RefactoringStatus();
                    errorStatus.addFatalError(e.getLocalizedMessage());
                    return errorStatus;
                }
            }

            IJavaElement targetJavaElement = getTargetJavaElementForOriginalJavaElement(originalJavaElement);
            if (targetJavaElement == null) {
                // The element does not need to be refactored
                continue;
            }

            try {
                Refactoring jdtRefactoring = createJdtRefactoring(originalJavaElement, targetJavaElement, status, pm);
                if (jdtRefactoring != null) {
                    if (prepareRefactoring(originalJavaElement, targetJavaElement)) {
                        RefactoringStatus conditionsStatus = jdtRefactoring.checkAllConditions(pm);
                        status.merge(conditionsStatus);
                    }
                }
            } catch (CoreException e) {
                RefactoringStatus errorStatus = new RefactoringStatus();
                errorStatus.addFatalError(e.getLocalizedMessage());
                return errorStatus;
            }
        }

        // Assure that every status message is only contained and thus shown once
        RefactoringStatus finalStatus = new RefactoringStatus();
        List<String> messages = new ArrayList<String>(status.getEntries().length);
        for (RefactoringStatusEntry entry : status.getEntries()) {
            if (messages.contains(entry.getMessage())) {
                continue;
            }
            messages.add(entry.getMessage());
            finalStatus.addEntry(entry);
        }

        return finalStatus;
    }

    /**
     * Iterates over all generated {@link IJavaElement}s and performs the appropriate JDT
     * refactorings.
     * 
     * @see RefactoringParticipant#createChange(IProgressMonitor)
     */
    public final Change createChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {
        /*
         * The Java elements need to be sorted in such a way that types are processed after
         * everything else because otherwise members may not be found anymore (because the type they
         * refer to does no longer exist).
         */
        List<IJavaElement> sortedOriginalJavaElements = sortJavaElements(originalJavaElements);

        for (int i = 0; i < getNumberOfJavaElementsToRefactor(); i++) {
            IJavaElement originalJavaElement = sortedOriginalJavaElements.get(i);

            /*
             * Do not try to refactor non-existing Java elements as the user may want to try to
             * start the refactoring when there is no source code at all. This also solves the
             * problem of what should happen when there is a Java element that occurs in the
             * implementation as well as in the published interface. If for example a setter method
             * occurs in the implementation as well as in the published interface then the first
             * encountered will be refactored. The second no longer exists then because the JDT
             * rename method refactoring renamed it already.
             */
            if (!(originalJavaElement.exists())) {
                continue;
            }

            // Do not refactor constructors
            if (originalJavaElement instanceof IMethod) {
                if (((IMethod)originalJavaElement).isConstructor()) {
                    continue;
                }
            }

            IJavaElement targetJavaElement = getTargetJavaElementForOriginalJavaElement(originalJavaElement);
            if (targetJavaElement == null) {
                // The element does not need to be refactored
                continue;
            }

            /*
             * We can't use the refactoring instances created during condition checking because the
             * Java references are build upon creation of the refactoring instance. These might
             * become invalid when refactorings are performed. Because of that new instances are
             * created here.
             */
            Refactoring jdtRefactoring = createJdtRefactoring(originalJavaElement, targetJavaElement,
                    new RefactoringStatus(), pm);
            if (jdtRefactoring != null) {
                if (prepareRefactoring(originalJavaElement, targetJavaElement)) {
                    performRefactoring(jdtRefactoring, pm);
                }
                finalizeRefactoring(originalJavaElement, targetJavaElement);
            }
        }

        return new NullChange();
    }

    /**
     * This operation is called right before a JDT refactoring is executed and may be implemented by
     * subclasses in order to do preparations.
     * <p>
     * Must return true if the refactoring may be executed, false otherwise. Note that
     * {@link #finalizeRefactoring(IJavaElement, IJavaElement)} will be called in any way.
     * <p>
     * The default implementation just does nothing and always returns true.
     * 
     * @param originalJavaElement The {@link IJavaElement} as it is before the refactoring
     * @param targetJavaElement The {@link IJavaElement} as it will be after the refactoring
     * 
     * @throws CoreException If any error occurs
     */
    protected boolean prepareRefactoring(IJavaElement originalJavaElement, IJavaElement targetJavaElement)
            throws CoreException {

        return true;
    }

    /**
     * This operation is called right after a JDT refactoring was executed and may be implemented by
     * subclasses in order to do clean up.
     * <p>
     * The default implementation just does nothing.
     * 
     * @param originalJavaElement The {@link IJavaElement} as it was before the refactoring
     * @param targetJavaElement The {@link IJavaElement} as it is after the refactoring
     * 
     * @throws CoreException If any error occurs
     */
    protected void finalizeRefactoring(IJavaElement originalJavaElement, IJavaElement targetJavaElement)
            throws CoreException {

        // Empty default implementation
    }

    /**
     * Creates and returns a sorted version of the given list of Java elements.
     * <p>
     * The elements will be sorted in such a way that types are located at the very end of the list.
     */
    private List<IJavaElement> sortJavaElements(List<IJavaElement> javaElements) {
        List<IType> collectedTypes = new ArrayList<IType>(2);
        List<IJavaElement> sortedJavaElements = new ArrayList<IJavaElement>(getNumberOfJavaElementsToRefactor());
        for (int i = 0; i < getNumberOfJavaElementsToRefactor(); i++) {
            if (javaElements.get(i).getElementType() == IJavaElement.TYPE) {
                collectedTypes.add((IType)javaElements.get(i));
            } else {
                sortedJavaElements.add(javaElements.get(i));
            }
        }
        sortedJavaElements.addAll(collectedTypes);
        return sortedJavaElements;
    }

    private void performRefactoring(final Refactoring refactoring, final IProgressMonitor pm) {
        Display.getDefault().syncExec(new Runnable() {
            @Override
            public void run() {
                IWorkspaceRunnable operation = new PerformRefactoringOperation(refactoring,
                        CheckConditionsOperation.FINAL_CONDITIONS);
                try {
                    operation.run(pm);
                } catch (CoreException e) {
                    throw new RuntimeException(e);
                }
            }
        });
    }

    /**
     * This implementation initializes the list of generated {@link IJavaElement}s for the provided
     * {@link IIpsObjectPartContainer}.
     * <p>
     * Returns false in case the element passed to this operation is not an
     * {@link IIpsObjectPartContainer} or if the parent {@link IIpsProject}'s builder set is not a
     * {@link StandardBuilderSet}. Otherwise the subclass implementation is called to initialize the
     * {@link IJavaElement}s that will be generated for the {@link IIpsObjectPartContainer} after
     * the refactoring has finished and true is returned.
     */
    public final boolean initialize(Object element) {
        if (!(element instanceof IIpsObjectPartContainer)) {
            return false;
        }

        IIpsObjectPartContainer ipsObjectPartContainer = (IIpsObjectPartContainer)element;
        IIpsArtefactBuilderSet ipsArtefactBuilderSet = ipsObjectPartContainer.getIpsProject()
                .getIpsArtefactBuilderSet();
        if (!(ipsArtefactBuilderSet instanceof StandardBuilderSet)) {
            return false;
        }

        ipsProject = ipsObjectPartContainer.getIpsProject();

        StandardBuilderSet standardBuilderSet = (StandardBuilderSet)ipsArtefactBuilderSet;
        boolean success = initializeOriginalJavaElements(ipsObjectPartContainer, standardBuilderSet);
        if (success) {
            success = initializeTargetJavaElements(ipsObjectPartContainer, standardBuilderSet);
        }

        return success;
    }

    /**
     * Responsible for returning whether the target Java element that maps to the given original
     * Java element.
     * <p>
     * Returns null if there is no target Java element for the given original Java element, which
     * means that the original Java element does not need to be refactored.
     * <p>
     * The default implementation searches for the element for which
     * <ul>
     * <li>the names are equal
     * <li>the element types of the parent elements are equal and
     * <li>the names of the parent elements either both end with the generation concept name
     * abbreviation or both do not.
     * </ul>
     * <p>
     * Subclasses should override this method as necessary.
     * 
     * @param originalJavaElement The original Java element to find the corresponding target Java
     *            element for
     */
    protected IJavaElement getTargetJavaElementForOriginalJavaElement(IJavaElement originalJavaElement) {
        for (IJavaElement targetJavaElement : targetJavaElements) {
            boolean namesOk = originalJavaElement.getElementName().equals(targetJavaElement.getElementName());
            if (!namesOk) {
                continue;
            }

            int originalParentType = originalJavaElement.getParent().getElementType();
            int targetParentType = targetJavaElement.getParent().getElementType();
            boolean parentTypesOk = originalParentType == targetParentType;
            if (parentTypesOk && originalParentType == IJavaElement.TYPE) {
                IType originalParent = (IType)originalJavaElement.getParent();
                IType targetParent = (IType)targetJavaElement.getParent();
                try {
                    if (originalParent.isInterface()) {
                        parentTypesOk = targetParent.isInterface();
                    } else if (originalParent.isEnum()) {
                        parentTypesOk = targetParent.isInterface();
                    } else if (originalParent.isClass()) {
                        parentTypesOk = targetParent.isClass();
                    }
                } catch (JavaModelException e) {
                    throw new RuntimeException(e);
                }
            }
            if (!parentTypesOk) {
                continue;
            }

            String originalParentName = originalJavaElement.getParent().getElementName();
            String targetParentName = targetJavaElement.getParent().getElementName();
            String generationConceptNameAbbreviation = ipsProject.getChangesInTimeNamingConventionForGeneratedCode()
                    .getGenerationConceptNameAbbreviation();
            boolean parentNamesOk = originalParentName.endsWith(generationConceptNameAbbreviation)
                    && targetParentName.endsWith(generationConceptNameAbbreviation)
                    || !originalParentName.endsWith(generationConceptNameAbbreviation)
                    && !targetParentName.endsWith(generationConceptNameAbbreviation);
            if (!parentNamesOk) {
                continue;
            }

            // All checks passed
            return targetJavaElement;
        }

        return null;
    }

    /**
     * Initializes the original Java elements generated for the given
     * {@link IIpsObjectPartContainer}.
     * <p>
     * This implementation asks the builder set for the generated elements of the given
     * {@link IIpsObjectPartContainer}. This behavior may be overwritten by subclasses.
     */
    protected boolean initializeOriginalJavaElements(IIpsObjectPartContainer ipsObjectPartContainer,
            StandardBuilderSet builderSet) {

        originalJavaElements = builderSet.getGeneratedJavaElements(ipsObjectPartContainer);
        return true;
    }

    /**
     * Subclass implementation responsible for initializing the {@link IJavaElement}s that will be
     * generated for the {@link IIpsObjectPartContainer} after the refactoring has finished.
     * 
     * @param ipsObjectPartContainer The {@link IIpsObjectPartContainer} to be refactored
     * @param builderSet A reference to the {@link StandardBuilderSet} to ask for generated Java
     *            elements
     */
    protected abstract boolean initializeTargetJavaElements(IIpsObjectPartContainer ipsObjectPartContainer,
            StandardBuilderSet builderSet);

    /**
     * Initializes the target {@link IJavaElement}s for the given {@link IIpsObject}.
     * 
     * @param ipsObject The {@link IIpsObject} to be refactored
     * @param targetIpsPackageFragment The new {@link IIpsPackageFragment} of the {@link IIpsObject}
     * @param newName The new name of the {@link IIpsObject}
     * @param builderSet A reference to the {@link StandardBuilderSet} to ask for generated Java
     *            elements
     * 
     * @throws NullPointerException If any parameter is null
     */
    protected final boolean initTargetJavaElements(IIpsObject ipsObject,
            IIpsPackageFragment targetIpsPackageFragment,
            String newName,
            StandardBuilderSet builderSet) {

        ArgumentCheck.notNull(new Object[] { ipsObject, targetIpsPackageFragment, newName, builderSet });

        Change undoDeleteChange = new NullChange();
        try {
            // 1) Create temporary copy with time stamp to avoid file system problems
            IIpsSrcFile tempSrcFile = RefactorUtil.copyIpsSrcFileToTemporary(ipsObject.getIpsSrcFile(),
                    targetIpsPackageFragment, newName, null);
            IPath originalResourcePath = ipsObject.getIpsSrcFile().getCorrespondingResource().getFullPath();

            // 2) Delete original source file with delete refactoring for undo possibility
            DeleteResourceChange deleteResourceChange = new DeleteResourceChange(originalResourcePath, true);
            undoDeleteChange = deleteResourceChange.perform(null);

            // 3) Copy the temporary file to create the target file
            IIpsSrcFile targetSrcFile = RefactorUtil.copyIpsSrcFile(tempSrcFile, targetIpsPackageFragment, newName,
                    null);

            // 4) Delete the temporary file, we don't need it any longer
            tempSrcFile.getCorrespondingResource().delete(true, null);

            // 5) Obtain the generated Java elements for the target IPS object
            IIpsObject targetIpsObject = targetSrcFile.getIpsObject();
            targetJavaElements = builderSet.getGeneratedJavaElements(targetIpsObject);

            // 6) Clean up by deleting the target source file
            targetSrcFile.getCorrespondingResource().delete(true, null);

        } catch (CoreException e) {
            // The participant won't be initialized if a CoreException occurs
            IpsPlugin.log(e);
            return false;

        } finally {
            // Roll-back by performing the undo change of the delete refactoring
            try {
                undoDeleteChange.perform(new NullProgressMonitor());
            } catch (CoreException e) {
                throw new RuntimeException(e);
            }
        }

        return true;
    }

    /**
     * Allows subclasses to set the list of {@link IJavaElement}s that will be generated for the
     * {@link IIpsElement} after the refactoring has finished.
     * 
     * @param targetJavaElements The list of generated {@link IJavaElement}s after the refactoring
     *            has finished
     * 
     * @throws NullPointerException If the given list is null
     */
    protected final void setTargetJavaElements(List<IJavaElement> targetJavaElements) {
        ArgumentCheck.notNull(targetJavaElements);
        this.targetJavaElements = targetJavaElements;
    }

    protected final List<IJavaElement> getOriginalJavaElements() {
        return originalJavaElements;
    }

    protected final List<IJavaElement> getTargetJavaElements() {
        return targetJavaElements;
    }

    /**
     * Subclass implementation that is responsible for returning an appropriate JDT refactoring for
     * the given Java element.
     * <p>
     * May return null if no refactoring has to be performed.
     * 
     * @param originalJavaElement The original Java element as it is before the refactoring is
     *            performed
     * @param targetJavaElement The target Java element as it shall be after the refactoring was
     *            performed
     * @param status A {@link RefactoringStatus} to report problems to
     * @param progressMonitor The {@link IProgressMonitor} to report progress to should that be
     *            necessary
     * 
     * @throws CoreException If an error occurs during creation of the refactoring instance
     */
    protected abstract Refactoring createJdtRefactoring(IJavaElement originalJavaElement,
            IJavaElement targetJavaElement,
            RefactoringStatus status,
            IProgressMonitor progressMonitor) throws CoreException;

    private int getNumberOfJavaElementsToRefactor() {
        return originalJavaElements.size();
    }

}
