«IMPORT org::faktorips::devtools::stdbuilder»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::runtime»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::productcmpt::template»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::policycmpt::template::PolicyCmptAttributeExtension»

«DEFINE field FOR XPolicyAssociation-»
	«IF !derivedUnion-»
	    /**
	     * «localizedJDoc("FIELD_ASSOCIATION", name.toFirstUpper())»
	     * 
	     * @generated
	     */
		«IF oneToMany-»
			private «List_(targetInterfaceName)» «field(fieldName)»  = new «ArrayList(targetInterfaceName)»();
		«ELSE-»
			private «targetClassName» «field(fieldName)» = null;
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE methods FOR XPolicyAssociation-»
	«EXPAND ProductAssociation::getNumOf-»
	«EXPAND contains-»
	«EXPAND getters-»
	«EXPAND setterMethodsForToOne-»
	«EXPAND newMethods-»
	«EXPAND add-»
	«EXPAND remove-»
«ENDDEFINE»

«DEFINE contains FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public boolean «method(methodNameContains, targetInterfaceName, "objectToTest")» {
	        return «fieldName».contains(objectToTest);
	    }
    «ENDIF»
«ENDDEFINE»

«DEFINE getters FOR XPolicyAssociation-»
	«IF oneToMany»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public «List_(targetInterfaceName)» «method(methodNameGetter)» {
	        return «Collections()».unmodifiableList(«fieldName»);
	    }
	
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameGetSingle, "int", "index")» {
	        return «fieldName».get(index);
	    }
    «ELSE»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameGetSingle)» {
	        return «fieldName»;
	    }
    «ENDIF»
«ENDDEFINE»

«DEFINE setterMethodsForToOne FOR XPolicyAssociation-»
	«IF !oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public void «method(methodNameSetter, targetInterfaceName, "newObject")» {
			«EXPAND PropertyChangeSupport::storeOldValue-»
	        «methodNameSetInternal»(newObject);
			«EXPAND PropertyChangeSupport::notify-»
	    }

	    /**
	     * «localizedJDoc("METHOD_SET_OBJECT_INTERNAL", name.toFirstUpper())»
	     * 
	     * @generated
	     */
	    public void «method(methodNameSetInternal, targetInterfaceName, "newObject")»{
	        if («fieldName» != null) {
	            «fieldName».«methodNameInverseAssociationSetInternal»(null);
	        }
	        if (newObject != null) {
	            «EXPAND castIfNeccessary("newObject")».«methodNameInverseAssociationSetInternal»(this);
	        }
	        «fieldName» = «EXPAND castToImplementationIfNecessary» newObject;
	    }
    «ENDIF»
«ENDDEFINE»

«DEFINE castIfNeccessary(String varName) FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»
	(«EXPAND castToImplementationIfNecessary»«varName»)«ELSE-»
	«varName»«ENDIF-»
«ENDDEFINE»

«DEFINE castToImplementationIfNecessary FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»(«targetClassName»)«ENDIF-»
«ENDDEFINE»

«DEFINE newMethods FOR XPolicyAssociation-»
	«IF productRelevant-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameNew)»{
	        «targetClassName» «variableNameNewInstance» = new «targetClassName»();
			«EXPAND addOrSetNewInstance-»
	        «variableNameNewInstance».«initialize()»;
	        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
	        return «variableNameNewInstance»;
	    }
	
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameNew, targetProductCmptInterfaceName, targetProductCmptVariableName)» {
	        if («targetProductCmptVariableName» == null) {
	            return «methodNameNew»();
	        }
	        «targetInterfaceName» «variableNameNewInstance» = «targetProductCmptVariableName».«methodNameCreatePolicyCmptForTargetProductCmpt»(); 
			«EXPAND addOrSetNewInstance-»
	        «variableNameNewInstance».«initialize()»;
	        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
	        return «variableNameNewInstance»;
	    }
    «ENDIF-»
«ENDDEFINE»

«DEFINE addOrSetNewInstance FOR XPolicyAssociation-»
	«IF oneToMany-»
       	«methodNameAddInternal»(«variableNameNewInstance»);
    «ELSE-»
       	«methodNameSetInternal»(«variableNameNewInstance»);
    «ENDIF-»
«ENDDEFINE»

«DEFINE add FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameAdd, targetInterfaceName, "objectToAdd")»{
	        «methodNameAddInternal»(objectToAdd);
	        «EXPAND PropertyChangeSupport::notifyNewAssociation("objectToAdd")-»
	    }
	
	    /**
	     * «localizedJDoc("METHOD_ADD_OBJECT_INTERNAL", name)»
	     * 
	     * @generated
	     */
	    public void «method(methodNameAddInternal, targetInterfaceName, "objectToAdd")»{
	        if (objectToAdd == null) {
	            throw new NullPointerException("Can't add null to association «name» of " + this);
	        }
	        if («fieldName».contains(objectToAdd)) {
	            return;
	        }
	        «EXPAND synchronizeInverseCompositionIfNecessary-»
			«fieldName».add(objectToAdd);
	        «EXPAND synchronizeInverseAssociationIfNecessary-»
	    }
    «ENDIF-»
«ENDDEFINE»

«REM»
	Anforderung der ADD Methode: 
		- Valide Composition UND inverse Beziehung
«ENDREM»
«DEFINE synchronizeInverseCompositionIfNecessary FOR XPolicyAssociation-»
	«IF validComposition && hasInverseAssociation()-»
		«EXPAND castIfNeccessary("objectToAdd")».«methodNameInverseAssociationSetInternal»(this);
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseAssociationIfNecessary FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeReverseAssociation-»
		«IF oneToMany-»
			if («EXPAND varNameNullCheckIfNecessary("objectToAdd")» !objectToAdd.«methodNameInverseAssociationContains»(this)) {
				objectToAdd.«methodNameInverseAssociationAdd»(this);
			}
	    «ELSE-»
	    	if («EXPAND varNameNullCheckIfNecessary("objectToAdd")» objectToAdd.«methodNameGetter»()!=null) {
				«EXPAND castIfNeccessary("objectToAdd")».«methodNameSetter»(this);
			}
	    «ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE varNameNullCheckIfNecessary(String varName) FOR XPolicyAssociation-»
	«IF !inverseAssociation.oneToMany-»
		«varName» !=null &&
	«ENDIF-»
«ENDDEFINE»

«DEFINE remove FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameRemove, targetInterfaceName, "objectToRemove")»{
	        if (objectToRemove == null) {
	            return;
	        }
			«EXPAND removeAndDetach-»
	        «EXPAND PropertyChangeSupport::notifyRemovedAssociation("objectToRemove")-»
	    }
    «ENDIF-»
«ENDDEFINE»

«REM»
	Test nötig: Composition ohne inverse Relation
		-> alter Generator sollte if aber kein detatch generieren
«ENDREM»
«DEFINE removeAndDetach FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeReverseComposition-»
		if («fieldName».remove(objectToRemove)) {
			«EXPAND detachRemovedObject-»
		}
	«ELSE-»
		«fieldName».remove(objectToRemove);
	«ENDIF-»
«ENDDEFINE»

«DEFINE detachRemovedObject FOR XPolicyAssociation-»
	«IF hasInverseAssociation()-»
		«IF inverseAssociation.oneToMany-»
			objectToRemove.«methodNameInverseAssociationRemove»(this);
		«ELSE-»
			«EXPAND castIfNeccessary("objectToRemove")».«methodNameInverseAssociationSetInternal»(null);
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»
	«REM»«IF generateCodeToSynchronizeReverseComposition-»
		«IF hasInverseAssociation()-»
		«ENDIF-»
	«ELSE-»
		«IF hasInverseAssociation() && inverseAssociation.oneToMany-»
			objectToRemove.«methodNameInverseAssociationRemove»(this);
		«ELSE-»
			«EXPAND castIfNeccessary("objectToRemove")».«methodNameInverseAssociationSetInternal»(null);
		«ENDIF-»
	«ENDIF-»«ENDREM»