/*******************************************************************************
 * Copyright (c) 2005-2009 Faktor Zehn AG und andere.
 * 
 * Alle Rechte vorbehalten.
 * 
 * Dieses Programm und alle mitgelieferten Sachen (Dokumentationen, Beispiele, Konfigurationen,
 * etc.) duerfen nur unter den Bedingungen der Faktor-Zehn-Community Lizenzvereinbarung - Version
 * 0.1 (vor Gruendung Community) genutzt werden, die Bestandteil der Auslieferung ist und auch unter
 * http://www.faktorzehn.org/f10-org:lizenzen:community eingesehen werden kann.
 * 
 * Mitwirkende: Faktor Zehn AG - initial API and implementation - http://www.faktorzehn.de
 *******************************************************************************/

package org.faktorips.devtools.stdbuilder.productcmpttype.method;

import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IType;
import org.faktorips.codegen.JavaCodeFragmentBuilder;
import org.faktorips.datatype.Datatype;
import org.faktorips.datatype.ValueDatatype;
import org.faktorips.devtools.core.builder.BuilderHelper;
import org.faktorips.devtools.core.builder.JavaSourceFileBuilder;
import org.faktorips.devtools.core.model.ipsobject.IIpsObjectPartContainer;
import org.faktorips.devtools.core.model.ipsproject.IIpsProject;
import org.faktorips.devtools.core.model.pctype.IPolicyCmptType;
import org.faktorips.devtools.core.model.productcmpttype.IProductCmptType;
import org.faktorips.devtools.core.model.productcmpttype.IProductCmptTypeMethod;
import org.faktorips.devtools.core.model.type.IParameter;
import org.faktorips.devtools.stdbuilder.StdBuilderHelper;
import org.faktorips.devtools.stdbuilder.productcmpttype.GenProductCmptType;
import org.faktorips.devtools.stdbuilder.productcmpttype.GenProductCmptTypePart;
import org.faktorips.runtime.FormulaExecutionException;
import org.faktorips.util.LocalizedStringsSet;

/**
 * 
 * @author Daniel Hohenberger
 */
public class GenProdMethod extends GenProductCmptTypePart {

    private final static LocalizedStringsSet LOCALIZED_STRINGS = new LocalizedStringsSet(GenProdMethod.class);

    private IProductCmptTypeMethod method;

    public GenProdMethod(GenProductCmptType genProductCmptType, IProductCmptTypeMethod method) throws CoreException {
        super(genProductCmptType, method, LOCALIZED_STRINGS);
        this.method = method;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void generateConstants(JavaCodeFragmentBuilder builder, IIpsProject ipsProject, boolean generatesInterface)
            throws CoreException {
        // nothing to do
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void generateMemberVariables(JavaCodeFragmentBuilder builder,
            IIpsProject ipsProject,
            boolean generatesInterface) throws CoreException {
        // nothing to do
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void generateMethods(JavaCodeFragmentBuilder builder, IIpsProject ipsProject, boolean generatesInterface)
            throws CoreException {
        if (generatesInterface) {
            generateMethodInterface(builder, ipsProject);
        } else {
            generateMethodImpl(builder, ipsProject);
        }
    }

    private void generateMethodImpl(JavaCodeFragmentBuilder methodsBuilder, IIpsProject ipsProject)
            throws CoreException {
        if (method.isFormulaSignatureDefinition()) {
            if (method.getModifier().isPublished()) {
                // nothing to do, signature is generated by the interface builder, implementation by
                // the product component builder.
            } else {
                methodsBuilder.javaDoc(getJavaDocCommentForOverriddenMethod(),
                        JavaSourceFileBuilder.ANNOTATION_GENERATED);
                generateSignatureForModelMethod(true, false, methodsBuilder, ipsProject);
                methodsBuilder.append(';');
            }
            if (method.isOverloadsFormula()) {
                IProductCmptTypeMethod overloadedFormulaMethod = method.findOverloadedFormulaMethod(ipsProject);
                methodsBuilder.appendln();
                methodsBuilder.javaDoc(getJavaDocCommentForOverriddenMethod(),
                        JavaSourceFileBuilder.ANNOTATION_GENERATED);
                getGenProductCmptType().getGenerator(overloadedFormulaMethod).generateSignatureForModelMethod(false,
                        false, methodsBuilder, ipsProject);
                methodsBuilder.openBracket();
                methodsBuilder.appendln("// TODO a delegation to the method " + method.getSignatureString()
                        + " needs to be implemented here");
                methodsBuilder.appendln("// And make sure to disable the regeneration of this method.");
                methodsBuilder.append("throw new ");
                methodsBuilder.appendClassName(RuntimeException.class);
                methodsBuilder.appendln("(\"Not implemented yet.\");");
                methodsBuilder.closeBracket();
            }
            return;
        }
        if (method.getModifier().isPublished()) {
            methodsBuilder.javaDoc(getJavaDocCommentForOverriddenMethod(), JavaSourceFileBuilder.ANNOTATION_GENERATED);
        } else {
            methodsBuilder.javaDoc(method.getDescription(), JavaSourceFileBuilder.ANNOTATION_GENERATED);
        }

        generateSignatureForModelMethod(method.isAbstract(), false, methodsBuilder, ipsProject);
        if (!method.isAbstract()) {
            methodsBuilder.openBracket();
            methodsBuilder.appendln("// TODO implement method!");
            Datatype datatype = method.getIpsProject().findDatatype(method.getDatatype());
            if (!datatype.isVoid()) {
                if (datatype.isValueDatatype()) {
                    methodsBuilder.appendln("return " + ((ValueDatatype)datatype).getDefaultValue() + ';');
                } else {
                    methodsBuilder.appendln("return null;");
                }
            }
            methodsBuilder.closeBracket();
        } else {
            methodsBuilder.append(';');
        }
    }

    private void generateMethodInterface(JavaCodeFragmentBuilder methodsBuilder, IIpsProject ipsProject)
            throws CoreException {

        if (method.getModifier().isPublished()) {
            methodsBuilder.javaDoc(method.getDescription(), JavaSourceFileBuilder.ANNOTATION_GENERATED);
            generateSignatureForModelMethod(false, false, methodsBuilder, ipsProject);
            methodsBuilder.append(';');
        }
    }

    public void generateSignatureForModelMethod(boolean isAbstract,
            boolean parametersFinal,
            JavaCodeFragmentBuilder methodsBuilder,
            IIpsProject ipsProject) throws CoreException {
        generateSignatureForModelMethod(isAbstract, parametersFinal, methodsBuilder, null, EMPTY_STRING_ARRAY,
                EMPTY_STRING_ARRAY, ipsProject);
    }

    /**
     * Code sample:
     * 
     * <pre>
     * public abstract Money computePremium(Policy policy, Integer age) throws FormulaException
     * </pre>
     */
    public void generateSignatureForModelMethod(boolean isAbstract,
            boolean parametersFinal,
            JavaCodeFragmentBuilder methodsBuilder,
            String methodSuffix,
            String[] testParameterNames,
            String[] testParameterTypes,
            IIpsProject ipsProject) throws CoreException {
        boolean formulaTest = testParameterNames.length > 0 && testParameterTypes.length > 0 || methodSuffix != null;

        IParameter[] parameters = method.getParameters();
        int modifier = method.getJavaModifier() | (isAbstract ? Modifier.ABSTRACT : 0);
        boolean resolveTypesToPublishedInterface = method.getModifier().isPublished();
        String returnClass = StdBuilderHelper.transformDatatypeToJavaClassName(method.getDatatype(),
                resolveTypesToPublishedInterface, getGenProductCmptType().getBuilderSet(), method.getIpsProject());

        String[] parameterNames = null;
        if (formulaTest) {
            List<IParameter> parametersWithoutTypes = new ArrayList<IParameter>();
            for (int i = 0; i < parameters.length; i++) {
                Datatype datatype = parameters[i].findDatatype(ipsProject);
                if (!(datatype instanceof IPolicyCmptType || datatype instanceof IProductCmptType)) {
                    parametersWithoutTypes.add(parameters[i]);
                }
            }
            parameters = parametersWithoutTypes.toArray(new IParameter[parametersWithoutTypes.size()]);
        }
        parameterNames = BuilderHelper.extractParameterNames(parameters);
        String[] parameterTypes = StdBuilderHelper.transformParameterTypesToJavaClassNames(parameters,
                resolveTypesToPublishedInterface, getGenProductCmptType().getBuilderSet(), method.getIpsProject());
        String[] parameterInSignatur = parameterNames;
        String[] parameterTypesInSignatur = parameterTypes;
        if (formulaTest) {
            // add test parameters
            parameterInSignatur = extendArray(parameterNames, testParameterNames);
            parameterTypesInSignatur = extendArray(parameterTypes, testParameterTypes);
        } else {
            parameterInSignatur = parameterNames;
            parameterTypesInSignatur = parameterTypes;
        }

        String methodName = method.getName();
        // extend the method signature with the given parameter names
        if (methodSuffix != null) {
            methodName = method.getName() + methodSuffix;
        }
        methodsBuilder.signature(modifier, returnClass, methodName, parameterInSignatur, parameterTypesInSignatur,
                parametersFinal);

        if (method.isFormulaSignatureDefinition()) {
            methodsBuilder.append(" throws ");
            methodsBuilder.appendClassName(FormulaExecutionException.class);
        }
    }

    private String[] extendArray(String[] source1, String[] source2) {
        String[] dest = new String[source1.length + source2.length];
        System.arraycopy(source1, 0, dest, 0, source1.length);
        System.arraycopy(source2, 0, dest, source1.length, source2.length);
        return dest;
    }

    @Override
    public void getGeneratedJavaElementsForImplementation(List<IJavaElement> javaElements,
            IType generatedJavaType,
            IIpsObjectPartContainer ipsObjectPartContainer,
            boolean recursivelyIncludeChildren) {

        // TODO AW: Not implemented yet.
    }

    @Override
    public void getGeneratedJavaElementsForPublishedInterface(List<IJavaElement> javaElements,
            IType generatedJavaType,
            IIpsObjectPartContainer ipsObjectPartContainer,
            boolean recursivelyIncludeChildren) {

        // TODO AW: Not implemented yet.
    }

}
