\section{Einleitung}

Faktor-IPS verwaltet Produktdaten während der Produktentwicklung in XML Dateien. 
Zur Laufzeit wird bisher (Version 2.5. und frühere Versionen) ebenfalls mit XML „Dateien“ gearbeitet.
Genau genommen muss man von XML‑Ressourcen sprechen, da die einzelnen XML‑Dateien meist in Bibliotheken (z.B. JAR-Dateien) zusammengefaßt
werden. Damit die Produktdaten geladen werden können, müssen sie zur Laufzeit im Classpath der Applikation verfügbar sein,
entweder als einzelne Dateien oder in Form von Bibliotheken.
Innerhalb einer Applikation kann auf die Produktdaten über die Klasse ClassloaderRuntimeRepository zugegriffen werden. Das ClassloaderRuntimeRepository lädt die Produktdaten über die Methode Class.getRessourceAsStream().

Da sowohl Programmcode als auch Produktdaten als Dateien vorliegen, können sie zusammen in einem Werkzeug wie CVS oder Subversion versioniert werden. Eine Version von Programmcode und Produktdaten kann dann in eine Zielumgebung transportiert werden. Im Fehlerfall können Fehler auch lokal in der Entwicklungsumgebung anhand der Version genau nachvollzogen werden.
Im JEE Umfeld können die Produktdaten zur Laufzeit allerdings nicht ohne weiteres separat vom Programmcode geändert werden. Der Grund liegt darin, dass nicht einzelne JAR-Dateien sondern EARs (Enterprise Archive) bzw. WARs (Web Application Archive) die „deploybaren“ Einheiten im JEE Umfeld sind. Da die JAR-Datei mit den Produktdaten Teil eines solchen Archives ist, muss bei Änderung der Produktdaten immer die gesamte Applikation neu deployed werden. 
In diesem Dokument wird beschrieben, wie Produktdaten unabhängig vom Programmcode deployed werden können.
RuntimeRepository
Das Repository welches zur Laufzeit die Produktdaten bereitstellt, ist durch das Interface IRuntimeRepository definiert. Der von Faktor-IPS generierte Sourcecode arbeitet ausschließlich gegen dieses Interface. Das ClassloaderRuntimeRepository stellt lediglich eine Implementierung dieses Interfaces dar. Um ein separates Deployment von Produktdaten zu ermöglichen, wird also eine Implementierung von IRuntimeRepository benötigt, welche die Produktdaten nicht aus XML-Ressourcen aus dem Classpath der Applikation lädt, sondern aus einer anderen Datenquelle, in der die Produktdaten unabhängig vom Programmcode ausgetauscht werden können. Zwei möglich Alternativen sind
Verwendung eines separaten Produktdatenservices, der die Produktdaten enthält.
Verwendung einer Datenbank
Im folgender wird die erste Alternative betrachtet. Im Anschluss einige Überlegungen zur Verwendung einer Datenbank dargestellt. 
Architektur mit Produktdatenservice
Der Produktdatenservice ist ein Stateless Session Bean (SLSB), welches die Produktdaten zur Verfügung stellt. Die Produktdaten sind zusammen mit dem SLSB in einem eigenen EAR gebundelt. Dadurch können die Produktdaten durch Deployment einer neuen Version des ProduktDataService-EARs ausgetauscht werden. 
Der Produktdatenservice kann die Produktdaten auf zwei Arten zur Verfügung stellen:
1.XML
Das Erzeugen der Instanzen der Modellklassen erfolgt dann im RuntimeRepository der eigentlichen Applikation.
2.Instanzen der Modellklassen (Produktbausteine, Tabellen, Enums).
Die Produktklassen des Modells würden in diesem Fall auch als Transportobjekte eingesetzt werden und müssten alle Serialisierbar sein. 

Formeln
Neben reinen Produktdaten können in Faktor-IPS in den Produktbausteinen auch Formeln zur Berechnung hinterlegt werden. Diese Formeln werden bisher (wiederum Version 2.5. und frühere Versionen) zur Entwicklungszeit bzw. beim „Build“ in Java Sourcecode übersetzt. Zur Laufzeit besteht die Produktinformation damit aus XML-Ressourcen und, falls Formeln verwendet werden, Java-Klassen.
Die Unterstützung von Formeln stellt eine besondere Herausforderung dar. Wieso? Eine Java-Klasse, die einmal von der virtuellen Maschine geladen wurde, kann nicht mehr verändert oder ausgetauscht werden. Wird nun also eine Formel geändert, beispielsweise weil sie fehlerhaft war, dann müsste man aber genau die alte Formelklasse durch die neue Formelklasse ersetzen. 
Eine Möglichkeit gibt es dies umzusetzen. Genau genommen existiert eine Java-Klasse nicht einmal pro JVM, sondern einmal pro ClassLoader. Man könnte die Formelklassen also über einen eigenen ClassLoader laden und bei Änderungen einen neuen ClassLoader verwenden. Da ApplicationServer allerdings selber massiv Gebrauch von dieser Möglichkeit machen, ist die Erzeugung eigener ClassLoader im EJB Umfeld nicht gestattet.
Da die Möglichkeit, die Formeln zur Entwicklungs/Buildzeit in Java-Sourcecode zu übersetzen damit ausfällt, müssen die Formeln zur Laufzeit interpretiert werden. Hierzu gibt es zwei prinzipielle Varianten:
1.Entwickeln eines eigenen Interpreters für die Formelsprache
2.Übersetzen der Formeln zur Laufzeit in Java Sourcecode und Interpretation des Java-Sourcecodes. 
Da es bereits mehrere ausgereifte Möglichkeiten gibt, Java Sourcecode zu interpretieren, soll kein eigener Formelinterpreter geschrieben werden, sondern eine vorhandene Möglichkeit zur Interpretation von Java Sourcecode eingesetzt werden. In Frage kommen hier Java BeanShell und Groovy.
Java BeanShell1
BeanShell ist ein Interpreter für Java. In der Faktor-IPS Entwicklung wird er von Beginn an für die Ausführung der Junit-Testfälle verwendet. Standardisierung wird über den JSR-274 betrieben. Mit Aufkommen immer neuer Skriptsprachen für die JVM ist es aber sehr ruhig um BeanShell geworden.
Groovy2
Eine dynamische Sprache für die JVM. Eine Eigenschaft von Groovy ist, dass Java Sourcecode auch gültiger Groovy-Sourcecode ist. Groovy auch zudem als Scriptengine im Sinne des JSR 223 (ab Java 6) verwendet werden.
Wir favorisieren Groovy zur Interpretation der Formeln. Die Gründe hierfür sind:
Erste Performance-Messungen haben ergeben, dass die Ausführung der Formeln mit Groovy wesentlich performanter ist als mit Java BeanShell.
Zudem gibt es eine sehr aktive Groovy Community während bei der BeanShell Entwicklung in letzter Zeit wenig Fortschritt zu erkennen ist.
Caching & Hot Deployment
Um die Performance der Anwendung nicht zu verschlechtern, müssen die Produktinformationen gecached werden. Da das Parsen von XML eine relativ teure Operation ist, reicht es nicht aus, die XML-Daten lediglich innerhalb des Produktdatenservices zu cachen. Statt dessen müssen, wie bisher auch, die Instanzen (Produktbausteine, Tabellen) im RuntimeRepository der Applikation gecached werden. Damit benötigt man aber ein Konzept, um diesen Cache zu leeren, wenn die Produktdaten geändert wurden, die der Produktdatenservice zur Verfügung stellt. Zudem muss sichergestellt werden, dass innerhalb einer Verarbeitung innerhalb der Applikation mit konsistenten Produktdaten gearbeitet wird. 
Detaillierung siehe Foliensatz.
