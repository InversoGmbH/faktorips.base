«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::CommonGeneratorExtensions»

«DEFINE copyMethods FOR XPolicyCmptClass-»
	
   	«IF !abstract-»
    /**
     * {@inheritDoc}
     * 
     * @generated
     */
    «overrideAnnotation(true)»
    public «IModelObject()» «newCopy()» {
        «Map(IModelObject(), IModelObject())» copyMap = new «HashMap(IModelObject(), IModelObject())»();
        «className» newCopy = («className») «newCopyInternal("copyMap")»;
        «copyAssociationsInternal("newCopy", "copyMap")»;
        return newCopy;
    }
	«ENDIF-»
	
	/**
     * «localizedJDoc("METHOD_NEW_COPY_INTERNAL")»
     * 
     * @generated
     */
     «overrideAnnotationIfHasSupertype(false)»«REM»für Vertrag muss override angegeben werden«ENDREM»
    public «IModelObject()» «newCopyInternal(Map(IModelObject(), IModelObject())+" copyMap")» {
    	«IF hasSupertype()-»
	        «className» newCopy = («className»)copyMap.get(this);
	        if (newCopy == null) {
	            newCopy = new «className»();
	            newCopy.«copyProductCmptAndGenerationInternal("this")»;
	            «copyProperties("newCopy", "copyMap")»;
	        }
	        return newCopy;
    	«ELSE-»
	        throw new RuntimeException(
	                "This method has to be abstract. It needs to have an empty body because of a bug in JMerge.");
	    «ENDIF-»
    }

    /**
     * «localizedJDoc("METHOD_COPY_PROPERTIES")»
     * 
     * @generated
     */«REM»«overrideAnnotationIfHasSupertype(false)»«ENDREM»
    protected void «copyProperties(IModelObject()+" copy", Map(IModelObject(), IModelObject())+" copyMap")» {
        «IF attributesToCopy.size > 0 || associations.size > 0-»
        	super.copyProperties(copy, copyMap);
        	«EXPAND copyAttributes-»
        	«REM»
        	«EXPAND copyAssociations-»
        	«ENDREM»        
        «ELSE-»
        	«localizedComment("NOTHING_TO_DO")»
        «ENDIF-»
    }

    /**
     * «localizedJDoc("METHOD_COPY_ASSOCIATIONS_INTERNAL")»
     *
     * @generated
     */
     «overrideAnnotationIfHasSupertype(false)»
    public void «copyAssociationsInternal(IModelObject()+" abstractCopy", Map(IModelObject(), IModelObject())+" copyMap")» {
        «IF associationsToCopy.size > 0-»
        	«IF hasSupertype()-»
		        super.copyAssociationsInternal(abstractCopy, copyMap);
        	«ENDIF-»
	        «className» newCopy = («className»)abstractCopy;
	        «EXPAND copyAssociationInternal FOREACH associations-»
        «ELSE-»
        	«localizedComment("NOTHING_TO_DO")»
        «ENDIF-»
    }
«ENDDEFINE»

«REM»Siehe PolicyCmptImplClassBuilder Z.394«ENDREM»
«DEFINE copyAttributes FOR XPolicyCmptClass-»
    «className» concreteCopy = («className»)copy;
	«FOREACH attributesToCopy AS this-»
		«IF considerInCopySupport-»
	        concreteCopy.«fieldName» = «fieldName»;
	    «ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE copyAssociations FOR XPolicyCmptClass-»
	«className» concreteCopy = («className»)copy;
	«FOREACH associations AS this-»
		«IF considerInCopySupport-»
			«IF typeAssociation-»		
				«IF oneToMany-»
        			concreteCopy.«fieldName».addAll(«fieldName»);
				«ELSE-»
        			concreteCopy.«fieldName» = «fieldName»;
				«ENDIF-»
			«ELSE-»
				«IF oneToMany-»
					for («targetInterfaceName» «copySupportLoopVarName» : «fieldName») {
			            «targetClassName» «copySupportCopyVarName» = («targetClassName»)copyMap.get(«copySupportLoopVarName»);
			            ((«targetClassName»)«copySupportLoopVarName»).copyAssociationsInternal(«copySupportCopyVarName», copyMap);
			        }
			        for («Iterator(targetInterfaceName)» it = «fieldName».iterator(); it.hasNext();) {
			            «targetClassName» vertragsTeil = («targetClassName»)it.next();
			            «targetClassName» copyVertragsTeil = («targetClassName»)vertragsTeil.newCopyInternal(copyMap);
			            copyVertragsTeil.setSubVertragInternal(concreteCopy);
			            concreteCopy.subVertragsTeile.add(copyVertragsTeil);
			            copyMap.put(vertragsTeil, copyVertragsTeil);
       				}			
				«ELSE-»
			        if («fieldName» != null) {
			            «targetClassName» «copySupportCopyVarName» = («targetClassName»)copyMap.get(«fieldName»);
			            «fieldName».copyAssociationsInternal(«copySupportCopyVarName», copyMap);
			        }
			        
			        if (oneToOneVertragsTeil != null) {
			            concreteCopy.oneToOneVertragsTeil = (VertragsTeil)oneToOneVertragsTeil.newCopyInternal(copyMap);
			            concreteCopy.oneToOneVertragsTeil.setVertragInternal(concreteCopy);
			            copyMap.put(oneToOneVertragsTeil, concreteCopy.oneToOneVertragsTeil);
			        }
				«ENDIF-»
		    «ENDIF-»
	    «ENDIF-»
	«ENDFOREACH-»
        for (Iterator<IDeckung> it = deckungen.iterator(); it.hasNext();) {
            Deckung deckung = (Deckung)it.next();
            Deckung copyDeckung = (Deckung)deckung.newCopyInternal(copyMap);
            copyDeckung.setVertragInternal(concreteCopy);
            concreteCopy.deckungen.add(copyDeckung);
            copyMap.put(deckung, copyDeckung);
        }
        concreteCopy.nichtKonfigurierteVertragsklassen.addAll(nichtKonfigurierteVertragsklassen);
        for (Iterator<IVertragsTeil> it = subVertragsTeile.iterator(); it.hasNext();) {
            VertragsTeil vertragsTeil = (VertragsTeil)it.next();
            VertragsTeil copyVertragsTeil = (VertragsTeil)vertragsTeil.newCopyInternal(copyMap);
            copyVertragsTeil.setSubVertragInternal(concreteCopy);
            concreteCopy.subVertragsTeile.add(copyVertragsTeil);
            copyMap.put(vertragsTeil, copyVertragsTeil);
        }
        if (oneToOneVertragsTeil != null) {
            concreteCopy.oneToOneVertragsTeil = (VertragsTeil)oneToOneVertragsTeil.newCopyInternal(copyMap);
            concreteCopy.oneToOneVertragsTeil.setVertragInternal(concreteCopy);
            copyMap.put(oneToOneVertragsTeil, concreteCopy.oneToOneVertragsTeil);
        }
        for (Iterator<IDeckung> it = zusatzDeckungen.iterator(); it.hasNext();) {
            Deckung deckung = (Deckung)it.next();
            Deckung copyDeckung = (Deckung)deckung.newCopyInternal(copyMap);
            concreteCopy.zusatzDeckungen.add(copyDeckung);
            copyMap.put(deckung, copyDeckung);
        }
        concreteCopy.nichtKonfigurierteKlasseOneToOne = nichtKonfigurierteKlasseOneToOne;
«ENDDEFINE»

«REM»Siehe PolicyCmptImplClassBuilder Z.523«ENDREM»
«DEFINE copyAssociationInternal FOR XPolicyAssociation-»
	«IF considerInCopySupport-»
		«IF typeAssociation-»		
			«IF oneToMany-»
		        for («targetInterfaceName» «copySupportLoopVarName» : «fieldName») {
		            if (copyMap.containsKey(«copySupportLoopVarName»)) {
		                newCopy.«fieldName».remove(«copySupportLoopVarName»);
		                newCopy.«fieldName».add((«targetInterfaceName»)copyMap
		                        .get(«copySupportLoopVarName»));
		            }
		        }
			«ELSE-»
				if (copyMap.containsKey(«fieldName»)) {
					newCopy.«fieldName» = («targetClassName»)copyMap.get(«fieldName»);
				}
			«ENDIF-»
		«ELSE-»
			«IF oneToMany-»
				for («targetInterfaceName» «copySupportLoopVarName» : «fieldName») {
		            «targetClassName» «copySupportCopyVarName» = («targetClassName»)copyMap.get(«copySupportLoopVarName»);
		            ((«targetClassName»)«copySupportLoopVarName»).copyAssociationsInternal(«copySupportCopyVarName», copyMap);
		        }
			«ELSE-»
		        if («fieldName» != null) {
		            «targetClassName» «copySupportCopyVarName» = («targetClassName»)copyMap.get(«fieldName»);
		            «fieldName».copyAssociationsInternal(«copySupportCopyVarName», copyMap);
		        }
			«ENDIF-»
	    «ENDIF-»
    «ENDIF-»
«ENDDEFINE»
