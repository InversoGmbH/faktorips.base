/*******************************************************************************
 * Copyright (c) Faktor Zehn AG. <http://www.faktorzehn.org>
 * 
 * This source code is available under the terms of the AGPL Affero General Public License version
 * 3.
 * 
 * Please see LICENSE.txt for full license terms, including the additional permissions and
 * restrictions as well as the possibility of alternative license terms.
 *******************************************************************************/
package org.faktorips.runtime.model.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Helper class that represents a model type that was generated by Faktor-IPS and has all meta data
 * in annotations. The meta data for one model type is split in interface and implementation and may
 * have additional classes like generations for product components. This class could be used to read
 * the meta data annotations from these classes regardless of which class was annotated.
 * 
 */
public class AnnotatedType {

    private final List<Class<?>> annotatedClasses = new ArrayList<Class<?>>();

    private AnnotatedType(Class<?> modelClass) {
        add(getPublishedInterface(modelClass));
        add(getImplementationClass(modelClass));
        addOptionalProductGeneration();
    }

    private void addOptionalProductGeneration() {
        if (is(IpsChangingOverTime.class)) {
            Class<?> generationClass = get(IpsChangingOverTime.class).value();
            add(getPublishedInterface(generationClass));
            add(getImplementationClass(generationClass));
        }
    }

    private void add(Class<?> annotatedClass) {
        if (annotatedClass != null) {
            annotatedClasses.add(annotatedClass);
        }
    }

    /**
     * Creates a new {@link AnnotatedType} from the given class. The given class is either an
     * implementation or a published interface.
     * 
     * @param generatedClass The class that was generated for the model type
     * @return An instance of {@link AnnotatedType} for the given generated class
     */
    public static AnnotatedType from(Class<?> generatedClass) {
        return new AnnotatedType(generatedClass);
    }

    /**
     * Returns <code>true</code> if this represented type is annotated with the specified annotation
     * class.
     * 
     * 
     * @param annotationClass The annotation class that should be present
     * @return <code>true</code> if the annotation is present else <code>false</code>
     */
    public boolean is(Class<? extends Annotation> annotationClass) {
        for (Class<?> annotatedClass : annotatedClasses) {
            if (annotatedClass.isAnnotationPresent(annotationClass)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the specified annotation if present. Returns <code>null</code> if it is not present.
     * 
     * Use #is(Class) to check whether the annotation is present or not
     * 
     * @param annotationClass The class of the requested annotation
     * @return The requested annotation if present else null
     */
    public <T extends Annotation> T get(Class<T> annotationClass) {
        for (Class<?> annotatedClass : annotatedClasses) {
            if (annotatedClass.isAnnotationPresent(annotationClass)) {
                return annotatedClass.getAnnotation(annotationClass);
            }
        }
        return null;
    }

    /**
     * Returns all fields that are declared in this type. That means it collects all fields from the
     * implementation and published interface. If this type represents a product component type it
     * also adds all fields from generations.
     * 
     * @return A list of fields that are declared in this type
     */
    public List<Field> getDeclaredFields() {
        ArrayList<Field> result = new ArrayList<Field>();
        for (Class<?> annotatedClass : annotatedClasses) {
            result.addAll(Arrays.asList(annotatedClass.getDeclaredFields()));
        }
        return result;
    }

    /**
     * Returns all methods that are declared in this type. That means it collects all methods from
     * the implementation and published interface. If this type represents a product component type
     * it also adds all methods from generations.
     * 
     * @return A list of fields that are declared in this type
     */
    public List<Method> getDeclaredMethods() {
        ArrayList<Method> result = new ArrayList<Method>();
        for (Class<?> annotatedClass : annotatedClasses) {
            result.addAll(Arrays.asList(annotatedClass.getDeclaredMethods()));
        }
        return result;
    }

    /**
     * Returns the {@link ClassLoader} from the this annotated type. This {@link ClassLoader} could
     * be used to load further resources like corresponding property files.
     * 
     */
    public ClassLoader getClassLoader() {
        return annotatedClasses.get(0).getClassLoader();
    }

    /**
     * Returns the implementation class of this type.
     */
    public Class<?> getImplementationClass() {
        return getImplementationClass(annotatedClasses.get(0));
    }

    /**
     * Returns the published interface of this type.
     */
    public Class<?> getPublishedInterface() {
        return getPublishedInterface(annotatedClasses.get(0));
    }

    static Class<?> getPublishedInterface(Class<?> modelObjectClass) {
        if (modelObjectClass.isInterface()) {
            return modelObjectClass;
        } else {
            Class<?>[] interfaces = modelObjectClass.getInterfaces();
            for (Class<?> iface : interfaces) {
                if (iface.isAnnotationPresent(IpsPublishedInterface.class)) {
                    return iface;
                }
            }
            return null;
        }
    }

    static Class<?> getImplementationClass(Class<?> modelObjectClass) {
        if (modelObjectClass.isInterface()) {
            if (modelObjectClass.isAnnotationPresent(IpsPublishedInterface.class)) {
                return modelObjectClass.getAnnotation(IpsPublishedInterface.class).implementation();
            } else {
                throw new IllegalArgumentException("The interface " + modelObjectClass.getCanonicalName()
                        + " is no IPS published interface");
            }
        } else {
            return modelObjectClass;
        }
    }

}
