#File modified by LocalizationHelper
#Sun Aug 22 13:40:13 CEST 2010
PersistentAssociationInfo_joinColumnName=Join-Spaltenname
PersistentAssociationInfo_joinTableName=Join-Tabellenname
PersistentAssociationInfo_msgIsInvalid={0} ist ung\u00FCltig.
PersistentAssociationInfo_msgJoinTableNameExceedsMaximumLength=Der Join-Tabellenname ist länger als die maximal erlaubte Länge definiert in den Persistenz-Optionen. Die aktuelle Länge ist {0} und die maximal erlaubte Länge ist {1}.
PersistentAssociationInfo_msgLazyFetchNotSupported=Lazy Fetching wird nicht bei "toOne"-Assoziationen unterstützt.
PersistentAssociationInfo_msgMaxLengthExceeds=Die Länge vom {0} ist länger als die maximal erlaubte Länge definiert in den Persistenz-Optionen. Die aktuelle Länge ist {0} und die maximal erlaubte Länge ist {1}.
PersistentAssociationInfo_msgMustBeEmpty={0} muss {1} leer sein
PersistentAssociationInfo_msgNot=nicht
PersistentAssociationInfo_msgOwningSideManyToManyMarkedOnBothSides=Beide Seiten der Beziehung sind als Eigentümer markiert.
PersistentAssociationInfo_msgOwningSideManyToManyNotAllowed=Darf nicht als Eigentümer der Beziehung markiert werden, da eine Join-Tabelle nicht benötigt ist.
PersistentAssociationInfo_msgOwningSideMissing=Mindestens eine Seite der Beziehung muss als Eigentümer markiert werden.
PersistentAssociationInfo_msgTransientMismatch=>TRANSLATE_ME<If the association is marked as transient or if the persistent type is not entity, then target side must also be marked as transient and vise versa.
PersistentAssociationInfo_msgWarningManualyCodeMergeNecessary=>TRANSLATE_ME<It is necessary to fix the annotation manually on the field '{0}' in the corresponding java class, because the merging of annotaion changes in java code doesn't work correctly yet.
PersistentAssociationInfo_sourceColumnName=Source-Spaltenname
PersistentAssociationInfo_tagetColumnName=Target-Spaltenname
PersistentAttributeInfo_msgColumnNameLengthExceedsMaximumLength=Die Länge des Spaltennamens ist länger als die maximal erlaubte Länge definiert in den Persistenz-Optionen. Die aktuelle Länge ist {0} und die maximal erlaubte Länge ist {1}.
PersistentAttributeInfo_msgColumnPrecisionExceedsTheLimit=Spalten-Precision erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgColumnScaleExceedsTheLimit=Spalten-Scale erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgColumnSizeExceedsTheLimit=Spalten-Size erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgEmptyColumnName=Der Spaltenname ist leer.
PersistentTypeInfo_msgDiscriminatorAlreadyDefined=Der Diskriminatorwert "{0}" wird schon im Supertyp {1} verwendet.
PersistentTypeInfo_msgDiscriminatorColumnNameIsInvalid=>TRANSLATE_ME<The discriminator column name is invalid.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedBecauseMappedSuperclass=>TRANSLATE_ME<The discriminator definition is not allowed here because this type is marked as mapped superclass.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedNotRootEntity=>TRANSLATE_ME<The discriminator definition is not allowed here because this type is not the root entity.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedTypeNotDefDiscrColumn=>TRANSLATE_ME<The discriminator definition is not allowed here because this type doesn't define the discriminator column.
PersistentTypeInfo_msgDiscriminatorMustBeDefinedInTheRootEntity=>TRANSLATE_ME<The discriminator must be defined in the root entity {0}.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmpty=>TRANSLATE_ME<The discriminator value must be empty if the root entity doesn't define a discriminator column or the type is abstract.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmptyBecauseMappedSuperclass=>TRANSLATE_ME<The discriminator value must be empty because this type is marked as mapped superclass.
PersistentTypeInfo_msgDiscriminatorValueMustNotBeEmpty=>TRANSLATE_ME<The discriminator value must not be empty if the root entity defines the dicriminator column and the type is not abstract.
PersistentTypeInfo_msgDiscriminatorValueNotConform=>TRANSLATE_ME<The discriminator value does not conform to the specified descriminator datatype.
PersistentTypeInfo_msgDuplicateColumnName=>TRANSLATE_ME<Duplicate column name {0}
PersistentTypeInfo_msgFoundDuplicateColumnNameIn=>TRANSLATE_ME<. Found duplicate name in {0}.
PersistentTypeInfo_msgInvalidInheritanceStratedyCombination=>TRANSLATE_ME<Invalid combination of inheritance strategies. Resolve by changing strategy for either {0} ({1}) or {2} ({3})
PersistentTypeInfo_msgTableNameExceedsMaximumLength=>TRANSLATE_ME<The table name length exceeds the maximum length defined in the persistence options. The table name length is {0} and the maximum length is {1}.
PersistentTypeInfo_msgTableNameInvalid=>TRANSLATE_ME<The table name is invalid
PersistentTypeInfo_msgTableNameMustBeEmptyBecauseNameDefinedInSupertypeShouldBeUsed=>TRANSLATE_ME<The table name must be empty because the table name defined in the super type should be used.
PersistentTypeInfo_msgTableNameMustBeEmptyMappedSuperclass=>TRANSLATE_ME<The table name must empty because the policy component type is marked as mapped superclass.
PersistentTypeInfo_msgTableNameMustBeEmptyNotRootEntityAndInhStrategyIs=>TRANSLATE_ME<The table name must be empty because this is not the root entity and the inheritance strategy is: {0}
PersistentTypeInfo_msgTableNameOfRootEntityMustBeUsed=>TRANSLATE_ME<The table name of the root entity must be used because this is not the root entity and the inheritance strategy is: {0}
PersistentTypeInfo_msgUseTableDefInSupertypIsNotAllowed=>TRANSLATE_ME<No supertype specified, thus it is not possible to use the table defined in the supertyp.
PersistentTypeInfo_textEnabled=>TRANSLATE_ME<enabled
PolicyCmptType_productCmptType=Produktbausteintyp
PolicyCmptType_msg_ProductCmptTypeNameMissing=Der Name des Produktbausteintyps fehlt.
PolicyCmptType_TheTypeDoesNotConfigureThisType=Der Typ {0} konfiguriert diesen Typ nicht.
PolicyCmptType_msg_IfTheSupertypeIsNotConfigurableTheTypeCanBeConfigurable=Wenn der Supertyp nicht konfigurierbar ist, kann auch dieser Typ nicht konfigurierbar sein.
PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmpty=F\u00FCr Detail-to-Master-Beziehungen muss eine inverse Beziehung angegeben werden.
PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmptyIfDerivedUnionHasInverse=Es muss eine inverse Beziehung angegeben werden, wenn die abgeleitete Vereinigung eine inverse Beziehung besitzt.
PolicyCmptTypeAssociation_Association_msg_InverseOfMasterToDetailMustBeADetailToMaster=Die inverse Beziehung einer Master-to-Detail Beziehung muss eine Detail-to-Master Beziehung sein.
PolicyCmptTypeAssociation_InverseOfDetailToMasterMustBeAMasterToDetail=Die inverse Beziehung einer Detail-to-Master Beziehung muss eine Master-to-Detail Beziehung sein.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureIsMissing=Es fehlt die Referenz auf die Methode, die das Attribut {0} berechnet.
PolicyCmptTypeAttribute_TypeOfOverwrittenAttributeCantBeChanged=Der Typ eines ?berschriebenen Attributes kann nicht ge?ndert werden\!
PolicyCmptType_msgSubtypeConfigurableWhenSupertypeConfigurable=Der Supertyp ist konfigurierbar, deshalb muss dieser Typ auch konfigurierbar sein.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureDoesNotExists=Die angegebende Methode existiert nicht.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureHasADifferentDatatype=Die angegebende Methode hat einen anderen Datentyp wie dieses Attribut.
Association_msg_InverseAssociationInconsistentWithDerivedUnion=Die inverse Beziehung ist inkonsistent mit der abgeleiteten Vereinigung {0}.
Association_msg_AssociationNotFoundInTarget=Die Beziehung {0} existiert im Zieltyp {1} nicht.
Association_msg_InverseAssociationMismatch=Die inverse Beziehung nennt nicht diese Beziehung als ihre inverse Beziehung\!
Association_msg_InverseAssociationMustBeMarkedAsDerivedUnionToo=Die inverse Beziehung dieser Beziehung ist nicht als abgeleitete Vereinigung markiert.
Association_msg_InverseAssociationMustBeOfTypeAssociation=Die inverse Beziehung einer Assoziation muss eine Assoziation sein\!
Association_msg_DetailToMasterAssociationMustHaveMaxCardinality1=Eine Detail-to-Master-Beziehung muss die maximale Kardinalit\u00E4t 1 haben.
ValidationRule_msgFunctionNotExists=Die Funktion {0} existiert nicht.
ValidationRule_msgIgnored=Diese Regel wird in allen Gesch\u00E4ftsvorf\u00E4llen angewandt, diese Information wird ignoriert.
ValidationRule_msgUndefinedAttribute=Das angegebene Attribut ist in dem Vertragsteiltyp dieser Regel nicht definiert.
ValidationRule_msgOneBusinessFunction=Die Gesch\u00E4ftsvorf\u00E4lle f\u00FCr die die Regel angewandt werden soll m\u00FCssen festgelegt werden.
ValidationRule_msgCodeShouldBeProvided=Die Regel sollte einen Message Code enthaltenen, das erleichert z. B. das Testen der Regel.
ValidationRule_ConstantAttributesCantBeValidated=Konstante Attribute k\u00F6nnen nicht validiert werden\! 
ValidationRule_msgDuplicateEntries=Doppelte Eintr\u00E4ge.
ValidationRule_msgNoNewlineAllowed=Im Meldungstext ist kein Zeilenumbruch erlaubt.
ValidationRule_msgValueSetRule=Diese Regel kann nur f\u00FCr ein Attribut verwendet werden, dessen Wertebereich entweder vom Typ Bereich oder Aufz\u00E4hlung ist.
Attribute_msgAttributeCantBeProductRelevantIfTypeIsNot=Ein Attribut kann nicht konfiguriert werden, wenn der Typ nicht konfigurierbar ist.
Attribute_msgNothingToOverwrite=Das Attribut {0} existiert in der Supertyp-Hierarchie nicht, daher kann nichts \u00FCberschrieben werden.
Attribute_proposalForMsgCode={0}_UNGUELTIG
Attribute_proposalForRuleName=pruefe{0}
