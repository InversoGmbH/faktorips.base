«IMPORT org::faktorips::devtools::stdbuilder»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::model»
«IMPORT org::faktorips::runtime»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::policycmpt::model»
«IMPORT org::faktorips::devtools::stdbuilder::xpand::productcmpt::template»

«EXTENSION org::faktorips::devtools::stdbuilder::xpand::policycmpt::template::PolicyCmptAttributeExtension»
«EXTENSION org::faktorips::devtools::stdbuilder::xpand::template::ClassNames»

«DEFINE field FOR XPolicyAssociation-»
	«IF !derivedUnion-»
	    /**
	     * «localizedJDoc("FIELD_ASSOCIATION", name.toFirstUpper())»
	     * 
	     * @generated
	     */
		«IF oneToMany-»
			private «List_(targetInterfaceName)» «field(fieldName)»  = new «ArrayList(targetInterfaceName)»();
		«ELSE-»
			private «targetClassName» «field(fieldName)» = null;
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE methods FOR XPolicyAssociation-»
	«EXPAND ProductAssociation::getNumOf-»
	«EXPAND contains-»
	«EXPAND getters-»
	«EXPAND setterMethodsForToOne-»
	«EXPAND newMethods-»
	«EXPAND add-»
	«EXPAND remove-»
«ENDDEFINE»

«DEFINE contains FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public boolean «method(methodNameContains, targetInterfaceName, "objectToTest")» {
	        return «fieldName».contains(objectToTest);
	    }
    «ENDIF»
«ENDDEFINE»

«DEFINE getters FOR XPolicyAssociation-»
	«IF oneToMany»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public «List_(targetInterfaceName)» «method(methodNameGetter)» {
	        return «Collections()».unmodifiableList(«fieldName»);
	    }
	
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameGetSingle, "int", "index")» {
	        return «fieldName».get(index);
	    }
    «ELSE»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameGetSingle)» {
	        return «fieldName»;
	    }
    «ENDIF»
«ENDDEFINE»

«REM»TODO Generierung ohne ChangeSupport unterschiedlich! Siehe «ENDREM»
«DEFINE setterMethodsForToOne FOR XPolicyAssociation-»
	«IF !oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
	    «overrideAnnotation(true)»
	    public void «method(methodNameSetter, targetInterfaceName, "newObject")» {
			«EXPAND PropertyChangeSupport::storeOldValue-»
	        «methodNameSetInternal»(newObject);
			«EXPAND PropertyChangeSupport::notify-»
	    }

	    /**
	     * «localizedJDoc("METHOD_SET_OBJECT_INTERNAL", name.toFirstUpper())»
	     * 
	     * @generated
	     */
	    public void «method(methodNameSetInternal, targetInterfaceName, "newObject")»{
	    	«IF compositionMasterToDetail-»
		        if («fieldName» != null) {
		            «EXPAND synchronizeInverseCompositionIfNecessaryForSet(false, fieldName, "null")-»
		        }
		        if (newObject != null) {
		            «EXPAND synchronizeInverseCompositionIfNecessaryForSet(true, "newObject", "this")-»
		        }
		        «fieldName» = «EXPAND castToImplementationIfNecessary» newObject;
	        	«EXPAND synchronizeInverseAssociationIfNecessary(fieldName)-»
		    «ENDIF-»
		    «IF typeAssociation-»
		    	if (newObject == «fieldName») return;
		    	«IF hasInverseAssociation()-»
			        «targetInterfaceName» oldRefObject = «fieldName»;
			        «fieldName» = null;
			        «EXPAND cleanupOldReference("oldRefObject")-»
			    «ENDIF-»
		        «fieldName» = «EXPAND castToImplementationIfNecessary» newObject;
	        	«EXPAND synchronizeInverseAssociationIfNecessary(fieldName)-»
		    «ENDIF-»
	    }
    «ENDIF»
«ENDDEFINE»
«DEFINE synchronizeInverseCompositionIfNecessaryForSet(boolean cast, String varName, String newRef) FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForSet-»
		«IF cast»«EXPAND castIfNeccessary(varName)»«ELSE»«varName»«ENDIF».«methodNameInverseAssociationSetInternal»(«newRef»);
    «ENDIF-»
«ENDDEFINE»

«DEFINE cleanupOldReference(String varToCleanUp) FOR XPolicyAssociation-»
	«IF !oneToMany-»
		if(«varToCleanUp» != null){
        	«EXPAND cleanupOldReferenceInner(varToCleanUp)-»
		}
    «ELSE-»
    	«EXPAND cleanupOldReferenceInner(varToCleanUp)-»
    «ENDIF-»
«ENDDEFINE»
«DEFINE cleanupOldReferenceInner(String varToCleanUp) FOR XPolicyAssociation-»
	«IF inverseAssociation.oneToMany»
		«varToCleanUp».«methodNameInverseAssociationRemove»(this);
    «ELSE-»
		«varToCleanUp».«methodNameInverseAssociationSet»(null);    	
    «ENDIF-»
«ENDDEFINE»

«DEFINE castIfNeccessary(String varName) FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»
	(«EXPAND castToImplementationIfNecessary»«varName»)«ELSE-»
	«varName»«ENDIF-»
«ENDDEFINE»

«DEFINE castToImplementationIfNecessary FOR XPolicyAssociation-»
	«IF generatingPublishedInterfaces-»(«targetClassName»)«ENDIF-»
«ENDDEFINE»

«DEFINE newMethods FOR XPolicyAssociation-»
	«IF productRelevant-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameNew)»{
	        «targetClassName» «variableNameNewInstance» = new «targetClassName»();
			«EXPAND addOrSetNewInstance-»
	        «variableNameNewInstance».«initialize()»;
	        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
	        return «variableNameNewInstance»;
	    }
	
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public «targetInterfaceName» «method(methodNameNew, targetProductCmptInterfaceName, targetProductCmptVariableName)» {
	        if («targetProductCmptVariableName» == null) {
	            return «methodNameNew»();
	        }
	        «targetInterfaceName» «variableNameNewInstance» = «targetProductCmptVariableName».«methodNameCreatePolicyCmptForTargetProductCmpt»(); 
			«EXPAND addOrSetNewInstance-»
	        «variableNameNewInstance».«initialize()»;
	        «EXPAND PropertyChangeSupport::notifyNewAssociation(variableNameNewInstance)-»
	        return «variableNameNewInstance»;
	    }
    «ENDIF-»
«ENDDEFINE»

«DEFINE addOrSetNewInstance FOR XPolicyAssociation-»
	«IF oneToMany-»
       	«methodNameAddInternal»(«variableNameNewInstance»);
    «ELSE-»
       	«methodNameSetInternal»(«variableNameNewInstance»);
    «ENDIF-»
«ENDDEFINE»

«DEFINE add FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameAdd, targetInterfaceName, "objectToAdd")»{
	        «methodNameAddInternal»(objectToAdd);
	        «EXPAND PropertyChangeSupport::notifyNewAssociation("objectToAdd")-»
	    }
	
	    /**
	     * «localizedJDoc("METHOD_ADD_OBJECT_INTERNAL", name)»
	     * 
	     * @generated
	     */
	    public void «method(methodNameAddInternal, targetInterfaceName, "objectToAdd")»{
	        if (objectToAdd == null) {
	            throw new NullPointerException("Can't add null to association «name» of " + this);
	        }
	        if («fieldName».contains(objectToAdd)) {
	            return;
	        }
	        «EXPAND synchronizeInverseCompositionIfNecessaryForAdd-»
			«fieldName».add(objectToAdd);
	        «EXPAND synchronizeInverseAssociationIfNecessary("objectToAdd")-»
	    }
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseCompositionIfNecessaryForAdd FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForAdd-»
		«EXPAND castIfNeccessary("objectToAdd")».«methodNameInverseAssociationSetInternal»(this);
    «ENDIF-»
«ENDDEFINE»

«DEFINE synchronizeInverseAssociationIfNecessary(String objectToSynchronize) FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseAssociation-»
		«IF oneToMany-»
			if («EXPAND varNameNullCheckIfNecessary(objectToSynchronize)» !«objectToSynchronize».«methodNameInverseAssociationContains»(this)) {
				«objectToSynchronize».«methodNameInverseAssociationAdd»(this);
			}
	    «ELSE-»
	    	if («EXPAND varNameNullCheckIfNecessary(objectToSynchronize)» «objectToSynchronize».«methodNameInverseAssociationGet»()!=this) {
				«objectToSynchronize».«methodNameInverseAssociationSet»(this);
				«REM» Der alte Codegenerator baut hier evtl. einen Cast ein:
			        if (!varClassName.equals(getGenType().getQualifiedName(false))) {
			            code.append("((");
			            code.appendClassName(getGenType().getQualifiedName(false));
			            code.append(")" + varName + ").");
			        }
			        Wird das fuer Derived Union auch mal verwendet, oder ist das ueberfluessig?
				«ENDREM»
			}
	    «ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE varNameNullCheckIfNecessary(String varName) FOR XPolicyAssociation-»
	«IF !inverseAssociation.oneToMany-»
		«varName» !=null &&
	«ENDIF-»
«ENDDEFINE»

«DEFINE remove FOR XPolicyAssociation-»
	«IF oneToMany-»
	    /**
	     * {@inheritDoc}
	     * 
	     * @generated
	     */
		«overrideAnnotation(true)»
	    public void «method(methodNameRemove, targetInterfaceName, "objectToRemove")»{
	        if (objectToRemove == null) {
	            return;
	        }
			«EXPAND removeAndDetach-»
	        «EXPAND PropertyChangeSupport::notifyRemovedAssociation("objectToRemove")-»
	    }
    «ENDIF-»
«ENDDEFINE»

«REM»
	Test nötig: Composition ohne inverse Relation
		-> alter Generator sollte leeres if(){} aber kein detach generieren
«ENDREM»
«DEFINE removeAndDetach FOR XPolicyAssociation-»
	«IF generateCodeToSynchronizeInverseCompositionForRemove-»
		if («fieldName».remove(objectToRemove)) {
			«EXPAND detachRemovedObject-»
		}
	«ELSE-»
		«fieldName».remove(objectToRemove);
	«ENDIF-»
«ENDDEFINE»

«DEFINE detachRemovedObject FOR XPolicyAssociation-»
	«IF hasInverseAssociation()-»
		«IF inverseAssociation.oneToMany-»
			objectToRemove.«methodNameInverseAssociationRemove»(this);
		«ELSE-»
			«EXPAND castIfNeccessary("objectToRemove")».«methodNameInverseAssociationSetInternal»(null);
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE delegateEffectiveFromHasChanged FOR XPolicyAssociation-»
	«IF considerInEffectiveFromHasChanged-»
		«IF oneToMany-»
			for («Iterator(targetInterfaceName)» it = «fieldName».iterator(); it.hasNext();) {
	            «AbstractConfigurableModelObject()» child = («AbstractConfigurableModelObject()»)it.next();
	            child.effectiveFromHasChanged();
	        }
		«ELSE-»
			if («fieldName» != null) {
	            ((«AbstractConfigurableModelObject()»)«fieldName»).effectiveFromHasChanged();
	        }
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE validateDependents FOR XAssociation-»
	«IF considerInValidateDependents-»
        «IF oneToMany-»
	        if («methodNameGetNumOf»() > 0) {
	            for («targetInterfaceName» rel : «methodNameGetter»()) {
	                ml.add(rel.validate(context));
	            }
	        }
        «ELSE-»
        	if («fieldName» != null) {
	            ml.add(«fieldName».validate(context));
	        }
        «ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE createTargetFromXML FOR XPolicyAssociation-»
	«IF considerInCreateChildFromXML-»
        if ("«name»".equals(childEl.getNodeName())) {
            String className = childEl.getAttribute("class");
            if (className.length() > 0) {
                try {
                    «targetClassName» «createChildFromXMLLocalVarName» = («targetClassName»)Class.forName(className).newInstance();
                    «IF oneToMany-»
	                    «methodNameAdd»(«createChildFromXMLLocalVarName»);
                    «ELSE-»
	                    «methodNameSetter»(«createChildFromXMLLocalVarName»);                    	
                    «ENDIF-»
                    return «createChildFromXMLLocalVarName»;
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            return («AbstractModelObject()»)«methodNameNew»();
        }
	«ENDIF-»
«ENDDEFINE»
        