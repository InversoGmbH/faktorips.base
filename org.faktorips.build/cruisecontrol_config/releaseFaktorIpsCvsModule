#
# CVS Methods to use in releaseFaktorIps script 
#
createBranch()
{
  # $1 : FETCH_TAG
  # $2 : BRANCH_ROOT_TAG (optional)
  # remove branch example: cvs -d /usr/local/cvsroot rtag -d v2_2_3_rfinal module/project
  
  local FETCH_TAG=$1
  local BRANCH_ROOT_TAG=$2
  
  if [ -z "$FETCH_TAG" ] ; then
    echo "please specify the version the branch will be based on -version [version]"
    exit 1
  fi
  
  local BRANCH=$FETCH_TAG
  local BRANCH_TAG="Root_"$BRANCH

  echo "  Create branch parameter:"
  echo "  --------------------------------------------------------------------------------------"
  if [ -z $BRANCH_ROOT_TAG ] ; then
    echo -e "  starting point                                                 : \e[35mHEAD\e[0m"
  else  
    echo -e "  starting point                                                 : \e[35m${BRANCH_ROOT_TAG}\e[0m"
  fi
  echo -e "  tag before branch (starting point for merging the branch back) : \e[35m$BRANCH_TAG\e[0m"
  echo -e "  branchname                                                     : Create cvs branch \e[35m$BRANCH\e[0m"
  echo "  --------------------------------------------------------------------------------------"
  echo -e "  Build Environment:"
  echo -e "    JAVA_HOME=\e[35m$JAVA_HOME\e[0m"
  echo -e "    ANT_HOME=\e[35m$ANT_HOME\e[0m"
  echo -e "    CVS_ROOT=\e[35m$CVS_ROOT\e[0m"
  echo -e "    cvs logfile=\e[35m$CVS_LOG\e[0m"  
  echo "  --------------------------------------------------------------------------------------"
  echo -e "=> Start creating branch (\e[33my\e[0m)es? <="
  echo 
  read ANSWER
  if [ ! "$ANSWER" = "y" ]
    then echo "Cancel"; exit 1
  fi
  
  echo "branching "$BRANCH" ..."

  # branch pluginbuilder projekt
  branchProject $PLUGINBUILDER_PROJECT_NAME
  
  # branch integrationtets projects
  for project in $INTEGRATIONTEST_PROJECTS ; do
    branchProject $project
  done
  
  # branch all projects specified in the pluginbuilder map file (all necessary plugin and feature projects)
  cvs -d $CVS_ROOT co -d $PLUGINBUILDER_PROJECT_DIR/maps $PLUGINBUILDER_PROJECT_NAME/maps/all_copy.map
  for project in $( cat $PLUGINBUILDER_PROJECT_DIR/maps/all_copy.map | sed -r "s/.*COPY,@WORKSPACE@,(.*)/\1/g" ) ; do
    branchProject $project
  done	
}

branchProject()
{
	# $1 : project name
	local PROJECTNAME=$1
	
  # 1. create root tag as start point for the branch 
  if [ -z $BRANCH_ROOT_TAG ] ; then
    echo "tagging LATEST with branch tag: '"$BRANCH_TAG"', project "$PROJECTNAME
    cvs -d $CVS_ROOT rtag -R $BRANCH_TAG $PROJECTNAME >> $CVS_LOG 2>&1
  else
    echo "tagging (use existing tag '${BRANCH_ROOT_TAG}') with branch tag: '"$BRANCH_TAG"', project "$PROJECTNAME
    cvs -d $CVS_ROOT rtag -R -r $BRANCH_ROOT_TAG $BRANCH_TAG $PROJECTNAME >> $CVS_LOG 2>&1
  fi
  # 2. branch project 
  #  -r : says that this branch should be rooted to this revision
  echo "create branch: '"$BRANCH"', project "$PROJECTNAME
  cvs -d $CVS_ROOT rtag -R -b -r $BRANCH_TAG $BRANCH $PROJECTNAME >> $CVS_LOG 2>&1
}

assertCvsEnvironment()
{
  if [ -z "$CVS_ROOT" ] ; then
    echo "CVS_ROOT not specified!"
    exit 1
  fi
  if [ ! -f $CVS_LOG ] ; then
    echo "cvs logfile: $CVS_LOG not exists!"
    exit 1
  fi  
}

checkoutModule()
{
  # $1 : destination dir $TMP_CHECKOUTDIR1 
  # $2 : tag $FETCH_TAG 
  # $3 : modulename $FAKTORIPS_CORE_PLUGIN_NAME/META-INF
  # $4 : branch (optional) $BRANCH
  
  local _TARGET=$1
  local _TAG=$2
  local _MODULE=$3
  local _BRANCH=$4
  
  assertCvsEnvironment
  
  if [ -d $_TARGET ] ; then 
    rm -r $_TARGET
  fi
  
  if [ -n "$_BRANCH" ] ; then
    echo "checkout using branch: "$_BRANCH", module: "$_MODULE", tag: "$_TAG
    if [ ! "$_TAG" = "LATEST" ] ; then
      # first try using tag
      set +e # must be set to continue if cvs fails (e..g branch not exists)
      cvs -d $CVS_ROOT co -d $_TARGET -r $_TAG $_MODULE >> $CVS_LOG 2>&1
      RC=$?
      set $BASH_PARAM
      if [ $RC -eq 0 ] ; then
        return
      fi
      # nothing found using tag, checkout without using tag
      if [ -d $_TARGET ] ; then
	    rm -r $_TARGET # delete is necessary because CVS stores the previous used tag
	  fi 
    fi
    echo "use Branch latest"
    set +e # must be set to continue if cvs fails (e..g branch not exists)
    cvs -d $CVS_ROOT co -d $_TARGET -r $_BRANCH $_MODULE >> $CVS_LOG 2>&1
    RC=$?
    set $BASH_PARAM
  else
    echo "checkout HEAD module: "$_MODULE", tag: "$_TAG
    if [ ! "$_TAG" = "LATEST" ] ; then
      # first try using tag
      set +e # must be set to continue if cvs fails (e.g. tag not exists)
      cvs -d $CVS_ROOT co -d $_TARGET -r $_TAG $_MODULE >> $CVS_LOG 2>&1
      RC=$?
      set $BASH_PARAM
      if [ $RC -eq 0 ] ; then
        return
      fi
      # nothing found using tag, checkout without using tag
      if [ -d $_TARGET ] ; then
        rm -r $_TARGET # delete is necessary because CVS stores the previous used tag
      fi
    fi
    echo "use HEAD latest"
    cvs -d $CVS_ROOT co -d $_TARGET $_MODULE >> $CVS_LOG 2>&1
  fi
}

tagProject()
{
  # $1 : Tag
  # $2 : Module
  # $3 : Branch (optional)
  local _TAG=$1
  local _MODULE=$2
  local _BRANCH=$3
  
  assertCvsEnvironment

  #     -> rtag : tag current versions of projects in repository
  #     -> -F : move tag if it already exists (overwrite checked above, by searching for existing release.properties)
  #     -> -R : process directories recursively
  #     -> -r rev : existing revision/tag
  if [ -n "$_BRANCH" ] ; then
    echo "tagging $_TAG using branch: "$_BRANCH", module: "$_MODULE
    cvs -d $CVS_ROOT rtag -F -R -r $_BRANCH $_TAG $_MODULE >> $CVS_LOG 2>&1
  else
    echo "tagging $_TAG using HEAD, module: "$_MODULE
    cvs -d $CVS_ROOT rtag -F -R $_TAG $_MODULE >> $CVS_LOG 2>&1
  fi
}

addAndCommit()
{
  # $1 file to add to cvs
  # $2 tag 
  local _FILE=$1
  local _TAG=$2

  assertCvsEnvironment
  
  # add new file to cvs
  cvs -d $CVS_ROOT add $_FILE
  
  # update file in cvs
  cvs -d $CVS_ROOT commit -m "release build, cvs tag $_TAG" $_FILE
  # always tag the new files
  cvs -d $CVS_ROOT tag -F $_TAG $_FILE
}
